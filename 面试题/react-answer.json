[
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 6,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/reactjinjie.gif",
        "style_tpl": 0,
        "text": "React不熟练怎么办",
        "title": "【专题课：React高级玩家必会指南】",
        "url": "https://mp.weixin.qq.com/s/NrgDKsi8H5SqEK9dVSPFsA"
      },
      "corp_tag": ["滴滴", "掌门一对一", "喜马拉雅", "蘑菇街"],
      "is_favorite": false,
      "qid": 25,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "react组件间通信常见的几种情况:\n- 1. 父组件向子组件通信\n- 2. 子组件向父组件通信\n- 3. 跨级组件通信\n- 4. 非嵌套关系的组件通信\n\n\n1）父组件向子组件通信：父组件通过 props 向子组件传递需要的信息。\n\n```js\n// 子组件: Child\nconst Child = props =>{\n  return <p>{props.name}</p>\n}\n\n// 父组件 Parent\nconst Parent = ()=>{\n    return <Child name=\"京程一灯\"></Child>\n}\n```\n\n2）子组件向父组件通信：: props+回调的方式。\n\n```js\n// 子组件: Child\nconst Child = props =>{\n  const cb = msg =>{\n      return ()=>{\n          props.callback(msg)\n      }\n  }\n  return (\n      <button onClick={cb(\"京程一灯欢迎你!\")}>京程一灯欢迎你</button>\n  )\n}\n\n// 父组件 Parent\nclass Parent extends Component {\n    callback(msg){\n        console.log(msg)\n    }\n    render(){\n        return <Child callback={this.callback.bind(this)}></Child>    \n    }\n}\n```\n\n\n3）跨级组件通信：即父组件向子组件的子组件通信，向更深层子组件通信。\n\n- 使用props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递props，增加了复杂度，并且这些props并不是中间组件自己需要的。\n- 使用context，context相当于一个大容器，我们可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现。\n\n```js\n// context方式实现跨级组件通信 \n// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据\n\nconst BatteryContext = createContext();\n\n//  子组件的子组件 \nclass GrandChild extends Component {\n    render(){\n        return (\n            <BatteryContext.Consumer>\n                {\n                    color => <h1 style={{\"color\":color}}>我是红色的:{color}</h1>\n                }\n            </BatteryContext.Consumer>\n        ) \n    }\n}\n\n//  子组件\nconst Child = () =>{\n    return (\n        <GrandChild/>\n    )\n}\n// 父组件\nclass Parent extends Component {\n      state = {\n          color:\"red\"\n      }\n      render(){\n          const {color} = this.state\n          return (\n          <BatteryContext.Provider value={color}>\n              <Child></Child>\n          </BatteryContext.Provider> \n          )\n      }\n}\n```\n\n4）非嵌套关系的组件通信：即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。\n- 1. 可以使用自定义事件通信（发布订阅模式）\n- 2. 可以通过redux等进行全局状态管理\n- 3. 如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。\n",
        "answer": "",
        "biz_type": 1,
        "qid": 25,
        "subject": "",
        "title": "React 组件通信方式"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 6,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/reactjinjie.gif",
        "style_tpl": 0,
        "text": "React不熟练怎么办",
        "title": "【专题课：React高级玩家必会指南】",
        "url": "https://mp.weixin.qq.com/s/NrgDKsi8H5SqEK9dVSPFsA"
      },
      "corp_tag": ["头条", "滴滴", "菜鸟网络", "挖财", "喜马拉雅"],
      "is_favorite": false,
      "qid": 27,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "1）背景\n\n- react在进行组件渲染时，从setState开始到渲染完成整个过程是同步的（“一气呵成”）。如果需要渲染的组件比较庞大，js执行会占据主线程时间较长，会导致页面响应度变差，使得react在动画、手势等应用中效果比较差。\n- 页面卡顿：Stack reconciler的工作流程很像函数的调用过程。父组件里调子组件，可以类比为函数的递归；对于特别庞大的vDOM树来说，reconciliation过程会很长(x00ms)，超过16ms,在这期间，主线程是被js占用的，因此任何交互、布局、渲染都会停止，给用户的感觉就是页面被卡住了。\n\n2）实现原理\n\n> 旧版 React 通过递归的方式进行渲染，使用的是 JS 引擎自身的函数调用栈，它会一直执行到栈空为止。而Fiber实现了自己的组件调用栈，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务。实现方式是使用了浏览器的requestIdleCallback这一 API。\n> Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示：\n\n```js\nconst fiber = {\n    stateNode,    // 节点实例\n    child,        // 子节点\n    sibling,      // 兄弟节点\n    return,       // 父节点\n}\n```\n\n- react内部运转分三层：\n  - Virtual DOM 层，描述页面长什么样。\n  - Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。\n  - Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。\n- 为了实现不卡顿，就需要有一个调度器 (Scheduler) 来进行任务分配。优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。任务的优先级有六种：\n  - synchronous，与之前的Stack Reconciler操作一样，同步执行\n  - task，在next tick之前执行\n  - animation，下一帧之前执行\n  - high，在不久的将来立即执行\n  - low，稍微延迟执行也没关系\n  - offscreen，下一次render时或scroll时才执行\n- Fiber Reconciler（react ）执行阶段：\n  - 阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。\n  - 阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。\n- Fiber树：Fiber Reconciler在阶段一进行Diff计算的时候，会基于Virtual DOM树生成一棵Fiber树，它的本质是链表。\n- 从Stack Reconciler到Fiber Reconciler，源码层面其实就是干了一件递归改循环的事情",
        "answer": "",
        "biz_type": 1,
        "qid": 27,
        "subject": "",
        "title": "说一下 react-fiber"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 6,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/reactjinjie.gif",
        "style_tpl": 0,
        "text": "React不熟练怎么办",
        "title": "【专题课：React高级玩家必会指南】",
        "url": "https://mp.weixin.qq.com/s/NrgDKsi8H5SqEK9dVSPFsA"
      },
      "corp_tag": ["掌门一对一"],
      "is_favorite": false,
      "qid": 26,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "1）状态管理\n- redux-sage 是 redux 的一个异步处理的中间件。\n- mobx 是数据管理库，和 redux 一样。\n\n2）设计思想\n- redux-sage 属于 flux 体系， 函数式编程思想。\n- mobx 不属于 flux 体系，面向对象编程和响应式编程。\n\n3）主要特点\n- redux-sage 因为是中间件，更关注异步处理的，通过  Generator 函数来将异步变为同步，使代码可读性高，结构清晰。action 也不是 action creator 而是 pure action，\n- 在 Generator 函数中通过 call 或者 put 方法直接声明式调用，并自带一些方法，如 takeEvery，takeLast，race等，控制多个异步操作，让多个异步更简单。\n- mobx 是更简单更方便更灵活的处理数据。 Store 是包含了 state 和 action。state 包装成一个可被观察的对象， action 可以直接修改 state，之后通过 Computed values 将依赖 state 的计算属性更新 ，之后触发 Reactions 响应依赖 state 的变更，输出相应的副作用 ，但不生成新的 state。\n\n4）数据可变性\n- redux-sage 强调 state 不可变，不能直接操作 state，通过 action 和 reducer 在原来的 state 的基础上返回一个新的 state 达到改变 state 的目的。\n- mobx 直接在方法中更改 state，同时所有使用的 state 都发生变化，不生成新的 state。\n\n5）写法难易度\n- redux-sage 比 redux 在 action 和 reducer 上要简单一些。需要用 dispatch 触发 state 的改变，需要 mapStateToProps 订阅 state。\n- mobx 在非严格模式下不用 action 和 reducer，在严格模式下需要在 action 中修改 state，并且自动触发相关依赖的更新。 \n\n6）使用场景\n- redux-sage 很好的解决了 redux 关于异步处理时的复杂度和代码冗余的问题，数据流向比较好追踪。但是 redux 的学习成本比 较高，代码比较冗余，不是特别需要状态管理，最好用别\n   的方式代替。\n- mobx 学习成本低，能快速上手，代码比较简洁。但是可能因为代码编写的原因和数据更新时相对黑盒，导致数据流向不利于追踪。",
        "answer": "",
        "biz_type": 1,
        "qid": 26,
        "subject": "",
        "title": "redux-saga 和 mobx 的比较"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 6,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/reactjinjie.gif",
        "style_tpl": 0,
        "text": "React不熟练怎么办",
        "title": "【专题课：React高级玩家必会指南】",
        "url": "https://mp.weixin.qq.com/s/NrgDKsi8H5SqEK9dVSPFsA"
      },
      "corp_tag": [
        "滴滴",
        "掌门一对一",
        "网易",
        "有赞",
        "沪江",
        "喜马拉雅",
        "酷家乐",
        "快手"
      ],
      "is_favorite": false,
      "qid": 6,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "1）对于正常的项目优化，一般都涉及到几个方面，**开发过程中**、**上线之后的首屏**、**运行过程的状态**\n\n- 来聊聊上线之后的首屏及运行状态：\n  - 首屏优化一般涉及到几个指标FP、FCP、FMP；要有一个良好的体验是尽可能的把FCP提前，需要做一些工程化的处理，去优化资源的加载\n  - 方式及分包策略，资源的减少是最有效的加快首屏打开的方式；\n  - 对于CSR的应用，FCP的过程一般是首先加载js与css资源，js在本地执行完成，然后加载数据回来，做内容初始化渲染，这中间就有几次的网络反复请求的过程；所以CSR可以考虑使用骨架屏及预渲染（部分结构预渲染）、suspence与lazy做懒加载动态组件的方式\n  - 当然还有另外一种方式就是SSR的方式，SSR对于首屏的优化有一定的优势，但是这种瓶颈一般在Node服务端的处理，建议使用stream流的方式来处理，对于体验与node端的内存管理等，都有优势；\n  - 不管对于CSR或者SSR，都建议配合使用Service worker，来控制资源的调配及骨架屏秒开的体验\n  - react项目上线之后，首先需要保障的是可用性，所以可以通过React.Profiler分析组件的渲染次数及耗时的一些任务，但是Profile记录的是commit阶段的数据，所以对于react的调和阶段就需要结合performance API一起分析；\n  - 由于React是父级props改变之后，所有与props不相关子组件在没有添加条件控制的情况之下，也会触发render渲染，这是没有必要的，可以结合React的PureComponent以及React.memo等做浅比较处理，这中间有涉及到不可变数据的处理，当然也可以结合使用ShouldComponentUpdate做深比较处理；\n  - 所有的运行状态优化，都是减少不必要的render，React.useMemo与React.useCallback也是可以做很多优化的地方；\n  - 在很多应用中，都会涉及到使用redux以及使用context，这两个都可能造成许多不必要的render，所以在使用的时候，也需要谨慎的处理一些数据；\n\n  - 最后就是保证整个应用的可用性，为组件创建错误边界，可以使用componentDidCatch来处理；\n\n- 实际项目中开发过程中还有很多其他的优化点：\n\n  - 1.保证数据的不可变性\n  - 2.使用唯一的键值迭代\n  - 3.使用web worker做密集型的任务处理\n  - 4.不在render中处理数据\n  - 5.不必要的标签，使用React.Fragments",
        "answer": "",
        "biz_type": 1,
        "qid": 6,
        "subject": "",
        "title": "React 项目中有哪些细节可以优化？实际开发中都做过哪些性能优化"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 2,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhuantaiguanli.gif",
        "style_tpl": 0,
        "text": "缺少实战经验？一键解决！",
        "title": "【专题课：你不知道的硬核数据状态管理】",
        "url": "https://mp.weixin.qq.com/s/k6MblcpoJNaTpVVp5Z0eZA"
      },
      "corp_tag": ["滴滴", "沪江"],
      "is_favorite": false,
      "qid": 17,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### React 事件绑定\n\nReact并不是将click事件绑在该div的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。\n另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。\n\n![react事件绑定原理](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-17.png)\n\n**1）事件注册**\n\n![事件注册流程](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-17-eventsign.png)\n\n- 组件装载 / 更新。\n- 通过lastProps、nextProps判断是否新增、删除事件分别调用事件注册、卸载方法。\n- 调用EventPluginHub的enqueuePutListener进行事件存储\n- 获取document对象。\n- 根据事件名称（如onClick、onCaptureClick）判断是进行冒泡还是捕获。\n- 判断是否存在addEventListener方法，否则使用attachEvent（兼容IE）。\n- 给document注册原生事件回调为dispatchEvent（统一的事件分发机制）。\n\n**2）事件存储**\n\n![事件存储](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-17-event-store.png)\n\n- EventPluginHub负责管理React合成事件的callback，它将callback存储在listenerBank中，另外还存储了负责合成事件的Plugin。\n- EventPluginHub的putListener方法是向存储容器中增加一个listener。\n- 获取绑定事件的元素的唯一标识key。\n- 将callback根据事件类型，元素的唯一标识key存储在listenerBank中。\n- listenerBank的结构是：listenerBank[registrationName][key]。\n\n```js\n{\n    onClick:{\n        nodeid1:()=>{...}\n        nodeid2:()=>{...}\n    },\n    onChange:{\n        nodeid3:()=>{...}\n        nodeid4:()=>{...}\n    }\n}\n```\n\n**3）事件触发执行**\n\n![事件触发执行](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-17-event.png)\n\n- 触发document注册原生事件的回调dispatchEvent\n- 获取到触发这个事件最深一级的元素\n\n这里的事件执行利用了React的批处理机制\n\n代码示例\n\n```js\n<div onClick={this.parentClick} ref={ref => this.parent = ref}>\n      <div onClick={this.childClick} ref={ref => this.child = ref}>\n          test\n     </div>\n</div>\n```\n\n- 首先会获取到this.child\n- 遍历这个元素的所有父元素，依次对每一级元素进行处理。\n- 构造合成事件。\n- 将每一级的合成事件存储在eventQueue事件队列中。\n- 遍历eventQueue。\n- 通过isPropagationStopped判断当前事件是否执行了阻止冒泡方法。\n- 如果阻止了冒泡，停止遍历，否则通过executeDispatch执行合成事件。\n- 释放处理完成的事件。\n\n**4）合成事件**\n\n![合成事件](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-17-conact.png)\n\n- 调用EventPluginHub的extractEvents方法。\n- 循环所有类型的EventPlugin（用来处理不同事件的工具方法）。\n- 在每个EventPlugin中根据不同的事件类型，返回不同的事件池。\n- 在事件池中取出合成事件，如果事件池是空的，那么创建一个新的。\n- 根据元素nodeid(唯一标识key)和事件类型从listenerBink中取出回调函数\n- 返回带有合成事件参数的回调函数\n\n**5）总流程**\n\n![总流程](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-17-eventrule.png)",
        "answer": "",
        "biz_type": 1,
        "qid": 17,
        "subject": "",
        "title": "React 事件绑定原理"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["滴滴"],
      "is_favorite": false,
      "qid": 7,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "\n\n### React 16.x \n\nReact 16.x的三大新特性 **Time Slicing、Suspense、hooks**\n\n1. **Time Slicing**（解决CPU速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得react能在性能极其差的机器跑时，仍然保持有良好的性能\n2. **Suspense** （解决网络IO问题）和lazy配合，实现异步加载组件。 能暂停当前组件的渲染, 当完成某件事以后再继续渲染，解决从react出生到现在都存在的「异步副作用」的问题，而且解决得非的优雅，使用的是「异步但是同步的写法」，我个人认为，这是最好的解决异步问题的方式\n3. 此外，还提供了一个内置函数 componentDidCatch，当有错误发生时, 我们可以友好地展示 fallback 组件；可以捕捉到它的子元素（包括嵌套子元素）抛出的异常；可以复用错误组件。\n\n#### 1.1 React16.8\n\n- 加入hooks，让React函数式组件更加灵活\n- hooks之前，React存在很多问题\n  - 在组件间复用状态逻辑很难\n  - 复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。\n  - class组件的this指向问题\n  - 难以记忆的生命周期\n- hooks很好的解决了上述问题，hooks提供了很多方法\n  - `useState` 返回有状态值，以及更新这个状态值的函数\n  - `useEffect` 接受包含命令式，可能有副作用代码的函数。\n  - `useContext` 接受上下文对象（从React.createContext返回的值）并返回当前上下文值，\n  - `useReducer useState` 的替代方案。接受类型为 `(state，action) => newState的reducer`，并返回与dispatch方法配对的当前状态。 \n  - `useCallback`  返回一个回忆的memoized版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性\n  - `useMemo` 纯的一个记忆函数\n  - `useRef` 返回一个可变的ref对象，其 `.current `属性被初始化为传递的参数，返回的 ref 对象在组件的整个生命周期内保持不变。\n  - `useImperativeMethods` 自定义使用ref时公开给父组件的实例值\n  - `useMutationEffect` 更新兄弟组件之前，它在React执行其DOM改变的同一阶段同步触发\n  - `useLayoutEffect` DOM改变后同步触发。使用它来从DOM读取布局并同步重新渲染\n\n#### 1.2 React16.9 \n\n- 重命名 Unsafe 的生命周期方法。新的 UNSAFE_ 前缀将有助于在代码 review 和 debug 期间，使这些有问题的字样更突出\n- 废弃 javascript: 形式的 URL。以 javascript: 开头的 URL 非常容易遭受攻击，造成安全漏洞。\n- 废弃 “Factory” 组件。 工厂组件会导致 React 变大且变慢。\n- `act()` 也支持异步函数，并且你可以在调用它时使用 await。\n- 使用 `<React.Profiler>` 进行性能评估。 在较大的应用中追踪性能回归可能会很方便 \n\n#### 1.3 React16.13.0\n\n- 支持在渲染期间调用setState，但仅适用于同一组件\n- 可检测冲突的样式规则并记录警告\n- 废弃 `unstable_createPortal`，使用 `createPortal`\n- 将组件堆栈添加到其开发警告中，使开发人员能够隔离bug并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。",
        "answer": "",
        "biz_type": 1,
        "qid": 7,
        "subject": "",
        "title": "react 最新版本解决了什么问题 加了哪些东西"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": [],
      "is_favorite": false,
      "qid": 766,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "#### 代码实现\n\n```js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nfunction replacer(key, value) {\n  if (typeof value === 'function') {\n    return `function ${value.name}() {...}`\n  }\n  return value\n}\n\nfunction stringify(value) {\n  return JSON.stringify(value, replacer, 2)\n}\n\nfunction DebuggerHOC(WrappedComponent) {\n  return class II extends WrappedComponent {\n    render() {\n      return (\n        <div>\n          <h2>\n            HOC 调试器组件\n          </h2>\n          <p>\n            Props\n          </p >\n          <pre>{stringify(this.props)}</pre>\n          <p>\n            State\n          </p >\n          <pre>{stringify(this.state)}</pre>\n          {super.render()}\n        </div>\n      )\n    }\n  }\n}\n\n// Props Proxy and state abstraction demonstration\nfunction PPHOC(WrappedComponent) {\n  return class PP extends React.Component {\n    constructor(props) {\n      super(props)\n      this.state = { fields: {} }\n    }\n\n    getField(fieldName) {\n      if (!this.state.fields[fieldName]) {\n        this.state.fields[fieldName] = {\n          value: '',\n          onChange: event => {\n            this.state.fields[fieldName].value = event.target.value\n            this.forceUpdate()\n          }\n        }\n      }\n\n      return {\n        value: this.state.fields[fieldName].value,\n        onChange: this.state.fields[fieldName].onChange\n      }\n    }\n\n    render() {\n      const props = Object.assign({}, this.props, {\n        fields: this.getField.bind(this),\n      })\n      return (\n        <div>\n          <h2>\n            PP HOC\n          </h2>\n          <p>我是一个Props代理HOC，抽象控制输入</p >\n          <WrappedComponent {...props}/>\n        </div>\n      )\n    }\n  }\n}\n\n\nclass Example extends React.Component {\n  render() {\n    return (\n      <div>\n        <h2>\n          Example组件\n        </h2>\n        <p>\n          Props\n        </p >\n        <pre>{stringify(this.props)}</pre>\n        <form>\n          <label>自动控制输入!</label>\n          <input type=\"email\" {...this.props.fields('email')}/>\n        </form>\n      </div>\n    )\n  }\n}\n\nexport default DebuggerHOC(PPHOC(Example))\n// const EnhancedExample = DebuggerHOC(PPHOC(Example))\n//\n// ReactDOM.render(<EnhancedExample date={(new Date).toISOString()}/>, document.getElementById('root'))\n```\n\n",
        "answer": "",
        "biz_type": 1,
        "qid": 766,
        "subject": "",
        "title": "如何实现双向绑定，并抽象成公共组件"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 4,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhiyeguihua.gif",
        "style_tpl": 0,
        "text": "前端路上没人带，老走弯路？",
        "title": "【专题课：十年前端老兵亲述：我和前端这十年】",
        "url": "https://mp.weixin.qq.com/s/J4qABCwfd6HyafOLLSgbvQ"
      },
      "corp_tag": [],
      "is_favorite": false,
      "qid": 764,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "#### 1.借助状态提升的方式间接实现通信\n\n即把组件之间要共享的状态提升至最近的共同父组件中统一管理。而任意一个兄弟组件可通过从父组件传来的回调函数更新共享状态，新的共享状态再通过父组件的props回传给子组件。\n\n#### 2.利用自定义事件\n\n也就是典型的发布订阅模式，通过向事件对象上添加监听器和触发事件来实现组件之间的通信。\n\n#### 3.利用context api\n\ncontext 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法\n\n#### 4.利用redux/mobx等全局状态管理工具",
        "answer": "",
        "biz_type": 1,
        "qid": 764,
        "subject": "",
        "title": "React兄弟组件的通信方式？(需回答两种以上)"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 6,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/reactjinjie.gif",
        "style_tpl": 0,
        "text": "React不熟练怎么办",
        "title": "【专题课：React高级玩家必会指南】",
        "url": "https://mp.weixin.qq.com/s/NrgDKsi8H5SqEK9dVSPFsA"
      },
      "corp_tag": [],
      "is_favorite": false,
      "qid": 765,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 一、Stack算法原理\n\n假如有A、B、C、D四个组件，层级结构为：\n\n![Stack](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-765-stach.png)\n\n**组件的生命周期为:**\n\n- 挂载阶段：constructor()、componentWillMount()、render()、componentDidMount()\n- 更新阶段为componentWillReceiveProps()、shouldComponentUpdate()、componentWillUpdate()、render()、componentDidUpdate\n\n**在挂载阶段，A,B,C,D的生命周期渲染顺序是**\n\n![组件生成周期](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-765-lifcycle.png)\n\n以render()函数为分界线。从顶层组件开始，一直往下，直至最底层子组件。然后再往上，组件update阶段同理。\n\n**Stack存在的问题**\n\n底层使用递归，递归并不好中途被打断，如果这是一个很大，层级很深的组件，react渲染它需要几十甚至几百毫秒，在这期间，react会一直占用浏览器主线程，任何其他的操作（包括用户的点击，鼠标移动等操作）都无法执行。这种情况下，页面就会出现卡顿甚至假死的现象。\n\n### 二、Fiber算法原理\n\nFiber架构用了分片的方式解决上面的问题，就是把一个任务分成很多小片，当分配给这个小片的时间用尽的时候，就检查任务列表中有没有新的、优先级更高的任务，有就做这个新任务，没有就继续做原来的任务。这种方式被叫做异步渲染(Async Rendering)。如下图所示：\n\n![异步渲染](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-654-fiber-arch.png)\n\n加入fiber的react将组件更新分为两个时期：phase1和phase2，这两个时期以render为分界，render前的生命周期为phase1,render后的生命周期为phase2。\n\n**phase1的生命周期是可以被打断的**，每隔一段时间它会跳出当前渲染进程，去确定是否有其他更重要的任务。此过程，React 在 workingProgressTree （并不是真实的virtualDomTree）上复用 current 上的 Fiber 数据结构来异步的（通过requestIdleCallback）来构建新的 tree，标记出需要更新的节点，放入队列中。\n\n**phase2的生命周期是不可被打断的**，React 将其所有的变更一次性更新到DOM上。这里最重要的是phase1这是时期所做的事。因此我们需要具体了解phase1的机制。如果不被打断，那么phase1执行完会直接进入render函数，构建真实的virtualDomTree。如果组件在phase1过程中被打断，即当前组件只渲染到一半（也许是在willMount,也许是willUpdate~反正是在render之前的生命周期），那么react会怎么干呢？ react会放弃当前组件所有干到一半的事情，去做更高优先级更重要的任务（当然，也可能是用户鼠标移动，或者其它react监听之外的任务），当所有高优先级任务执行完之后，react通过callback回到之前渲染到一半的组件，从头开始渲染。（看起来放弃已经渲染完的生命周期，会有点不合理，反而会增加渲染时长，但是react确实是这么干的）。也就是 所有phase1的生命周期函数都可能被执行多次，因为可能会被打断重来。因为可能会被执行多次，那么我们最好就得保证phase1的生命周期每一次执行的结果都是一样的，否则就会有问题，因此，最好都是纯函数。\n\n### 三、fiber数据结构\n\nfiber本质是个链表，有child和sibing属性，指向第一个子节点和相邻的兄弟节点，从而构成fiber tree。return属性指向其父节点。\n\n更新队列，updateQueue，是一个链表，有first和last两个属性，指向第一个和最后一个update对象。每个fiber有一个属性updateQueue指向其对应的更新队列。\n\n每个fiber（当前fiber可以称为current）有一个属性alternate，开始时指向一个自己的clone体，update的变化会先更新到alternate上，当更新完毕，alternate替换current。\n\n结构如下图所示：\n\n![fiber数据结构](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-654-fiberprinciple.png)\n\n由上图可以看出：通过链表，每个节点都可以找到它的父节点、兄弟节点、子节点。这里需要注意的是，父节点只指向它的第一个子节点，而不是全部，兄弟节点也是指向下一个兄弟节点，不是全部。\n\n### 四、关键API：requestIdleCallback\n\nMDN对该api描述如下：`window.requestIdleCallback()`方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。你可以在空闲回调函数中调用requestIdleCallback()，以便在下一次通过事件循环之前调度另一个回调。\n\n使用该方法，fiber实现了分片\n\n### 五、fiber 架构的本质\n\n1. 循环条件：利用 requestIdeCallback 空闲时间递减。\n2. 遍历过程：利用链表，找孩子找兄弟找父亲。\n3. React Fiber 是一种基于浏览器的单线程调度算法.React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使用了循环来代替之前的递归。\n\n`fiber`是React16的新特性，是对之前`diff`算法的重写，主要是把一次计算，改变为多次计算，在浏览器有高级任务时，暂停计算。`fiber`的问世就是为了解决之前大量计算导致浏览器掉帧的现象。\n\n相对于之前`stack`，源码上核心的变化就是将原先递归改为循环。\n\n旧版`stack`算法是一条路走到黑，运作的过程是不能被打断的，通过递归的方式进行渲染，使用的是JS引擎自身的函数调用栈，它会一直执行到栈空为止，由于JS是单线程的，所以大量计算会导致主线程长时间被占用。\n\n新版`fiber`实现了自己的调用栈，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务。实现方式是使用了浏览器的`requestIdleCallback`这一 API，在主线程空闲时计算。\n\n1）为了达到这种效果，就需要有一个调度器 (Scheduler) 来进行任务分配。\n\n任务的优先级有六种：\n\n- synchronous，与之前的Stack Reconciler操作一样，同步执行\n- task，在next tick之前执行\n- animation，下一帧之前执行\t\n- high，在不久的将来立即执行\n- low，稍微延迟执行也没关系\n- offscreen，下一次render时或scroll时才执行\n\n2）优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效\n\n`fiber`实际上是一种数据结构，用`js`对象表示就是：\n\n```js\nconst fiber = {\n    stateNode,    // 节点实例\t\n    child,        // 子节点\n    sibling,      // 兄弟节点\n    return,       // 父节点\n}\n```\n\n3）Fiber Reconciler 在执行过程中，会分为 2 个阶段。\n\n- 阶段一，生成`Fiber tree`，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。\n- 阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。\n\n阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。\n\n### 六、fiber与stack比较\n\n**1）数据结构的调整**\n\n- 现在使用扁平化的 链表 的数据存储结构，使用循环迭代来代替之前的递归；\n- 每个 VirtualDOM 节点内部现在使用 Fiber node表示,模拟函数调用栈，保存了节点处理的上下文信息，方便中断和恢复；\n\n```js\n export type Fiber = {\n    ...\n    //  链表结构\n    return: Fiber | null,  // 指向父节点，或者render该节点的组件\n    child: Fiber | null, // 指向第一个子节点\n    sibling: Fiber | null, // 指向下一个兄弟节点\n    ...\n}\n```\n\n**2）两个阶段的拆分**\n\n之前是一边Diff一边commit提交的, 现在分为两个阶段\n\n**①reconciliation 协调阶段** \n\n协调阶段是可以被打断的\n\n- constructor\n- componentWillMount 废弃\n- componentWillReceiveProps 废弃\n- static getDerivedStateFromProps\n- shouldComponentUpdate\n- componentWillUpdate 废弃\n- render\n\n因为Reconciliation阶段能被打断，所以会出现多次调用的情况，所以这些生命周期函数应该避免使用，16版之后标记为不安全的；\n\n**②commit 提交阶段**\n\n不能暂停，一直到界面更新完成；\n\n- getSnapshotBeforeUpdate()\n- componentDidMount\n- componentDidUpdate\n- componentWillUnmount\n\n该阶段为了正确地处理各种副作用，包括DOM变更、还有你在componentDidMount中发起的异步请求、useEffect 中定义的副作用等等。\n\n因为有副作用，所以必须保证按照次序只调用一次，况且会有用户可以察觉到的变更, 所以不能中断；\n\n### 七、总结\n\n旧版React在一些响应体验要求较高的场景不适用，比如动画，布局和手势。\n\n根本原因是渲染/更新过程一旦开始无法中断，持续占用主线程，主线程忙于执行JS，无暇他顾（布局、动画），造成掉帧、延迟响应（甚至无响应）等不佳体验。`Fiber`就是用来解决这类问题的，把渲染/更新过程拆分为小块任务，通过合理的调度机制来控制时间，更细粒度、更强的控制力。\n\nFiber：一种将 recocilation （递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。这种算法并没有减少渲染时间，相反，由于某些函数中途中断，再从头开始执行，时间反而有可能会增加。但是通过把重要的任务提前，空间时间执行非重要任务，解决了那些组件深层递归的页面的卡顿和假死现象，提升了用户体验。\n\n\n\n\n",
        "answer": "",
        "biz_type": 1,
        "qid": 765,
        "subject": "",
        "title": "Fiber算法原理，相比之前的stack算法哪些方面做了优化？"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["微医"],
      "is_favorite": false,
      "qid": 504,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "#### 1.RN\n\nRN是React Native的简称。其中React（有时叫React.js或ReactJS）是一套开源JavaScript 库（也可以称为前端 UI 框架），而React Native则是React向移动端的延伸。我们可以认为React Native分为两层，React 层是一套JavaScript 库；Native层则扮演桥梁的功能，根据平台不同映射为不同的原生控件；通过这种设计实现了—开发者构建的RN代码可以在不同的平台上（暂时支持Android和IOS）运行，也就是Learn once, write anywhere。\n\n\n#### 2.虚拟 DOM 对跨平台技术的意义\n\n为什么使用虚拟 DOM？\n\n是因为快（实际上不一定快）？。是因为解耦？是因为响应式？\n\n对跨平台技术来说，更重要的意义在于：\n\n虚拟 DOM 是 DOM 在内存中的一种轻量级表达方式，是一种统一约定！可以通过不同的渲染引擎生成不同平台下的 UI！\n\n虚拟 DOM 的可移植性非常好，这意味着可以渲染到 DOM 以外的任何端，发挥你的想象力，可以做的事情很多。\n\n所以这也是为什么3 大框架出现以后就出现很多 native（RN）框架。主要原因还是虚拟dom。\n\n> 注：虚拟 DOM 真正的价值从来都不是性能，而是不管数据怎么变化，都可以用最小的代价来更新 DOM，而且掩盖了底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。\n\n",
        "answer": "",
        "biz_type": 1,
        "qid": 504,
        "subject": "",
        "title": "为什么 3 大框架出现以后就出现很多 native（RN）框架（虚拟 DOM）"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 6,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/reactjinjie.gif",
        "style_tpl": 0,
        "text": "React不熟练怎么办",
        "title": "【专题课：React高级玩家必会指南】",
        "url": "https://mp.weixin.qq.com/s/NrgDKsi8H5SqEK9dVSPFsA"
      },
      "corp_tag": ["酷家乐"],
      "is_favorite": false,
      "qid": 538,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "#### 1.props \n\n- 函数组件的props就是一个函数的入参组件\n- 类组件：`this.props` 包括被该组件调用或者定义的props\n\n#### 2.state\n\n- 组件中的 state 包含了随时可能发生变化的数据。\n- state 由用户自定义，它是一个普通 JavaScript 对象。\n\n#### 3.区别\n\n- props 是传递给组件的（类似于函数的形参），而 state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。\n- props 是不可修改的，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。\n- state 是在组件中创建的，一般在 constructor中初始化 state\n- state 是多变的、可以修改，每次setState都异步更新的。",
        "answer": "",
        "biz_type": 1,
        "qid": 538,
        "subject": "",
        "title": "props 和 state 的区别"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 4,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhiyeguihua.gif",
        "style_tpl": 0,
        "text": "前端路上没人带，老走弯路？",
        "title": "【专题课：十年前端老兵亲述：我和前端这十年】",
        "url": "https://mp.weixin.qq.com/s/J4qABCwfd6HyafOLLSgbvQ"
      },
      "corp_tag": ["百分点"],
      "is_favorite": false,
      "qid": 546,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 无状态组件\n\n- 不依赖自身的状态state。\n- 可以是类组件或者函数组件。\n- 可以完全避免使用 this 关键字。(由于使用的是箭头函数事件无需绑定)\n- 有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态函数组件\n- 使用场景： 组件不需要管理 state ，纯展示\n\n无状态组件指的是组件内部不维护 `state`，只根据外部组件传入的 `props` 进行渲染的组件，当 `props` 改变时，组件重新渲染。\n\n有状态组件内部使用 `state`，维护自身状态的变化，有状态组件根据外部组件传入的 `props` 和自身的 `state` ，进行渲染。",
        "answer": "",
        "biz_type": 1,
        "qid": 546,
        "subject": "",
        "title": "对无状态组件的理解"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 2,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhuantaiguanli.gif",
        "style_tpl": 0,
        "text": "缺少实战经验？一键解决！",
        "title": "【专题课：你不知道的硬核数据状态管理】",
        "url": "https://mp.weixin.qq.com/s/k6MblcpoJNaTpVVp5Z0eZA"
      },
      "corp_tag": ["寺库"],
      "is_favorite": false,
      "qid": 509,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 实现\n\n以iOS为例，实现一个普通模块，iOS新建一个类继承NSObject实现RCTBridgeModule协议，在类实现文件里添加RCT_EXPORT_MODULE()的宏，标记自己是个准备给js调用的模块，这里可以传模块名，默认为类名。然后通过RCT_EXPORT_METHOD()或RCT_REMAP_METHOD()暴露方法给到js调用，结果可以通过block回调，也可以是返回一个Promise。在js层通过NativeModules.模块名.方法名来调用。\n\n如果是实现一个原生UI模块，则新建类继承RCTViewManager实现RCTBridgeModule协议，类里比普通模块多实现-(UIView *)view方法，返回一个原生组件的UIView实例。ReactJS 层使用时先使用requireNativeComponent方法引进，就可以在js层愉快的使用原生组件了。\n\n",
        "answer": "",
        "biz_type": 1,
        "qid": 509,
        "subject": "",
        "title": "RN 如何实现一个原生的组件？"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["寺库"],
      "is_favorite": false,
      "qid": 512,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 原理\n\n我们可以把RN整个架构分为三层\n\n**一是最上层我们写的React 的js代码层**，这里面写的代码是跑在jsc上，debug调试模式下跑在浏览器js解析引擎，通过websocket发送到移动设备。\n\n**第二层是RN建立的一个bridge桥接js和native** ,在0.59之前是所有通信都是json序列化后通过bridge异步通信，0.59开始用了新架构Fabric实现的JSI实现了js 和 native的直接共享内存调用，而无需再经过bridge。\n\n**三是native层**，主要渲染原生组件，和把事件传递出去。js上的虚拟节点是通过yoga解析，映射为原生组件再渲染，所以能实现一套js代码可以在安卓和ios上运行。\n\n在js层写的代码最终都会被打包为jsbundle文件，jsbundle里面是一个自执行的函数，参数为含所有模块标记的数组。\n\n以iOS为例，要在iOS上跑这个文件，主要通过RCTBridge初始化加载这个文件，然后 RCTRootView 初始化调用这个bridge。在RCTBridge 初始化过程中会在初始化一个 RCTCxxBridge 的实例batchedBridge 挂在自己身上，然后batchedBridge调用start方法，这个方法主要做4件事情：\n\n1. 是新建一个js线程，js代码执行就是跑在这个线程上，挂到 runloop 上让他不退出。\n\n2. 加载所有要暴露给js层的原生模块，包括RN实现的和开发者自己实现的，每个模块都生成对应的RCTModuleData。接着使用上面创建好的js线程执行Instance的初始化，过程中主要初始化了一个NativeToJsBridge实例变量，在这过程中又初始化了一个JSIExecutor的实例，这是Fabric架构的主角。\n\n3. 开始异步加载jsbundle资源，此步骤是和2一起开始的。\n\n4. 在2、3都完成之后则开始执行这个js代码，执行代码是调用RCTCxxBridge的executeSourceCode方法，在这方法里就一层层的使用了步骤2初始化的Instance，NativeToJsBridge，JSIExecutor。最后在JSIExecutor的loadApplicationScript方法里往js的执行环境向global注入了一个对象和两个方法，这个对象是nativeModuleProxy，是native 模块的配置信息，包含着native module 的模块id 和方法id，这个配置信息在原生一侧也缓存了一份，在未来js调用native时，就是传着模块id 和方法id实现原生模块的调用。JSIExecutor最后会触发jsc的JSEvaluateScript方法执行js源码。\n\n在js源码执行完成后，RCTCxxBridge发通知给到RCTRootView去执行runApplication方法，这个方法会把模块名方法名等信息发到js层，AppRegistry的runApplication在被调用后做了一系列操作，然后开始创建试图，然后经过yoga解析渲染出原生UI。\n\n交互过程中，js call native时，js 不会直接调用native的方法，而是存在一个队列里等着native call js 后顺道带回去执行，如果native 迟迟未调用（超过预设时间5ms）则js 会调用之前注入到global 的 nativeFlushQueueImmediate方法，告诉native 快来执行。",
        "answer": "",
        "biz_type": 1,
        "qid": 512,
        "subject": "",
        "title": "RN 的原理，为什么可以同时在安卓和 IOS 端运行"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 2,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhuantaiguanli.gif",
        "style_tpl": 0,
        "text": "缺少实战经验？一键解决！",
        "title": "【专题课：你不知道的硬核数据状态管理】",
        "url": "https://mp.weixin.qq.com/s/k6MblcpoJNaTpVVp5Z0eZA"
      },
      "corp_tag": ["宝宝树"],
      "is_favorite": false,
      "qid": 517,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 区别\n\nRedux 是 JavaScript 应用状态容器，提供可预测化的状态管理。\n\n1. 相对于全局管理，Redux的状态是可以预测的、可追踪的，也就减少了代码维护，问题排查的成本\n2. Redux是一种状态管理的设计思想，全局管理是一种方式，概念不一致，另外全局管理可能会有命名冲突等问题",
        "answer": "",
        "biz_type": 1,
        "qid": 517,
        "subject": "",
        "title": "rudux 和全局管理有什么区别"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 6,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/reactjinjie.gif",
        "style_tpl": 0,
        "text": "React不熟练怎么办",
        "title": "【专题课：React高级玩家必会指南】",
        "url": "https://mp.weixin.qq.com/s/NrgDKsi8H5SqEK9dVSPFsA"
      },
      "corp_tag": ["百分点"],
      "is_favorite": false,
      "qid": 543,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 一、哪些方法会触发 react 重新渲染？\n\n#### 1.`setState()` 方法被调用\n\nsetState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候一定会重新渲染吗？\n\n答案是不一定。当 setState 传入 null 的时候，并不会触发 render。\n\n```js\nclass App extends React.Component {\n  state = {\n    a: 1\n  };\n\n  render() {\n    console.log(\"render\");\n    return (\n      <React.Fragement>\n        <p>{this.state.a}</p>\n        <button\n          onClick={() => {\n            this.setState({ a: 1 }); // 这里并没有改变 a 的值\n          }}\n        >\n          Click me\n        </button>\n        <button onClick={() => this.setState(null)}>setState null</button>\n        <Child />\n      </React.Fragement>\n    );\n  }\n}\n```\n\n#### 2.父组件重新渲染\n\n只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么子组件也会重新渲染，进而触发 render。\n\n### 二、重新渲染 render 会做些什么？\n\n1. 会对新旧 VNode 进行对比，也就是我们所说的DoM diff。\n2. 对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面\n3. 遍历差异对象，根据差异的类型，根据对应对规则更新VNode\n\nReact 的处理 render 的基本思维模式是每次一有变动就会去重新渲染整个应用。在 Virtual DOM 没有出现之前，最简单的方法就是直接调用 innerHTML。Virtual DOM 厉害的地方并不是说它比直接操作 DOM 快，而是说不管数据怎么变，都会尽量以最小的代价去更新 DOM。React 将 render 函数返回的虚拟 DOM 树与老的进行比较，从而确定 DOM 要不要更新、怎么更新。当 DOM 树很大时，遍历两棵树进行各种比对还是相当耗性能的，特别是在顶层 setState 一个微小的修改，默认会去遍历整棵树。尽管 React 使用高度优化的 Diff 算法 ，但是这个过程仍然会损耗性能。\n\n### 三、总结\n\nReact 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以我们的业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。\n\n这里提下优化的点\n\n#### 1.shouldComponentUpdate 和 PureComponent\n\n在 React 类组件中，可以利用 shouldComponentUpdate 或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。\n\n#### 2.利用高阶组件\n\n在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能\n\n#### 3.使用 React.memo\n\nReact.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo 只能用于函数组件 。\n\n#### 4.合理拆分组件\n\n微服务的核心思想是：以更轻、更小的粒度来纵向拆分应用，各个小应用能够独立选择技术、发展、部署。我们在开发组件的过程中也能用到类似的思想。试想当一个整个页面只有一个组件时，无论哪处改动都会触发整个页面的重新渲染。在对组件进行拆分之后，render 的粒度更加精细，性能也能得到一定的提升。\n",
        "answer": "",
        "biz_type": 1,
        "qid": 543,
        "subject": "",
        "title": "哪些方法会触发 react 重新渲染？重新渲染 render 会做些什么？"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 6,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/reactjinjie.gif",
        "style_tpl": 0,
        "text": "React不熟练怎么办",
        "title": "【专题课：React高级玩家必会指南】",
        "url": "https://mp.weixin.qq.com/s/NrgDKsi8H5SqEK9dVSPFsA"
      },
      "corp_tag": ["百分点"],
      "is_favorite": false,
      "qid": 544,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 一、State & Props\n\n**props 是组件对外的接口，state 是组件对内的接口**。组件内可以引用其他组件，组件之间的引用形成了一个树状结构（组件树），如果下层组件需要使用上层组件的数据或方法，上层组件就可以通过下层组件的props属性进行传递，因此props是组件对外的接口。组件除了使用上层组件传递的数据外，自身也可能需要维护管理数据，这就是组件对内的接口state。根据对外接口props 和对内接口state，组件计算出对应界面的UI。\n\n组件的props 和 state都和组件最终渲染出的UI直接相关。两者的主要区别是：state是可变的，是组件内部维护的一组用于反映组件UI变化的状态集合；而props是组件的只读属性，组件内部不能直接修改props，要想修改props，只能在该组件的上层组件中修改。在组件状态上移的场景中，父组件正是通过子组件的props，传递给子组件其所需要的状态。  \n\n### 二、触发更新的生命周期的不同\n\n#### 1.更新state会触发的生命周期\n\n- getDerivedStateFormProps\n- shouldComponentUpdate\n- render\n- getSnapshotBeforeUpdate\n- componentDidUpdate\n\n```js\n// home.js\nimport React, { Component } from 'react'\nimport Info from './Info'\nexport default class Home extends Component {\n  state = {\n    InfoText: 'react 学习！！！'\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log('home getDerivedStateFromProps')\n    return {}\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('home shouldComponentUpdate')\n    return true\n  }\n\n  getSnapshotBeforeUpdate(nextProps, prevState) {\n    console.log('home getSnapshotBeforeUpdate')\n\n    return {}\n  }\n\n  componentDidUpdate() {\n    console.log('home componentDidUpdate')\n  }\n\n\n  componentDidMount() {\n    console.log('------------------------------------------------')\n    setTimeout(() => {\n      this.setState({\n        InfoText: '更新了'\n      })\n    }, 1000)\n  }\n  render() {\n    console.log('home render')\n    const { InfoText } = this.state\n    return (\n      <div>\n        <Info InfoText={InfoText} />\n      </div>\n    )\n  }\n}\n\n// home getDerivedStateFromProps\n// home getDerivedStateFromProps\n// home shouldComponentUpdate\n// home shouldComponentUpdate\n// home render\n// home render\n// home getSnapshotBeforeUpdate\n// home componentDidUpdate\n```\n\n#### 2.更新props子组件会触发的周期\n\n- getDerivedStateFormProps\n- shouldComponentUpdate\n- render\n- getSnapshotBeforeUpdate\n- componentDidUpdate\n\n```js\n// info.js\nimport React, { Component } from 'react'\n\nexport default class Info extends Component {\n  state = {}\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log('Info getDerivedStateFromProps')\n    return {}\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('Info shouldComponentUpdate')\n    return true\n  }\n\n  getSnapshotBeforeUpdate(nextProps, prevState) {\n    console.log('Info getSnapshotBeforeUpdate')\n\n    return {}\n  }\n  componentDidUpdate() {\n    console.log('Info componentDidUpdate')\n  }\n  render() {\n    console.log('Info render')\n    const { InfoText } = this.props\n    return (\n      <div>\n        <p>{InfoText}</p>\n      </div>\n    )\n  }\n}\n// Info getDerivedStateFromProps\n// Info getDerivedStateFromProps\n// Info shouldComponentUpdate\n// Info shouldComponentUpdate\n// Info render\n// Info render\n// Info getSnapshotBeforeUpdate\n// Info componentDidUpdate\n```\n\n### 三、总结\n\n共同点: 更新的时候触发的生命周期是相同的\n\n区别：在getDerivedStateFromProps、shouldComponentUpdate、getSnapshotBeforeUpdate。\n\n这几个周期中如果是更新state, 参数prevState会有值，nextProps是一个空对象\n\n这几个周期中如果是更新props, 参数nextProps会有值，prevState是一个空对象\n\n\n",
        "answer": "",
        "biz_type": 1,
        "qid": 544,
        "subject": "",
        "title": "state 和 props 触发更新的生命周期分别有什么区别？"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 4,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhiyeguihua.gif",
        "style_tpl": 0,
        "text": "前端路上没人带，老走弯路？",
        "title": "【专题课：十年前端老兵亲述：我和前端这十年】",
        "url": "https://mp.weixin.qq.com/s/J4qABCwfd6HyafOLLSgbvQ"
      },
      "corp_tag": ["寺库"],
      "is_favorite": false,
      "qid": 510,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 一、RN混原生\n\nRN 混原生，工程中大部分是RN，调用部分原生模块。\n\nRN调用原生可以实现调用设备API，实现使用原生功能。\n\n比如使用RN实现一个原生的组件\n\n以iOS为例，实现一个普通模块，iOS新建一个类继承NSObject实现RCTBridgeModule协议，在类实现文件里添加RCT_EXPORT_MODULE()的宏，标记自己是个准备给js调用的模块，这里可以传模块名，默认为类名。然后通过RCT_EXPORT_METHOD()或RCT_REMAP_METHOD()暴露方法给到js调用，结果可以通过block回调，也可以是返回一个Promise。在js层通过NativeModules.模块名.方法名来调用。\n\n如果是实现一个原生UI模块，则新建类继承RCTViewManager实现RCTBridgeModule协议，类里比普通模块多实现-(UIView *)view方法，返回一个原生组件的UIView实例。ReactJS 层使用时先使用requireNativeComponent方法引进，就可以在js层愉快的使用原生组件了。\n\n### 二、原生混 RN\n\n原生混用RN，RN的js代码最后都是打包为jsbundle文件，所以其实就是如何使用这个文件来渲染出一个原生组件和处理逻辑。\n\n原生可以使用多个RCTRootView加载执行不同的jsbundle文件，这些RCTRootView可以被addSubView到别的view 或者被UIViewController持有，以达到原生混用RN的目的。\n\n\u200c原生混用RN可以实现多业务拆分，rn实现的不同业务代码打包多个jsbundle文件，再由原生调用，可以业务间的独立性。",
        "answer": "",
        "biz_type": 1,
        "qid": 510,
        "subject": "",
        "title": "RN 混原生和原生混 RN 有什么不同？"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 2,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhuantaiguanli.gif",
        "style_tpl": 0,
        "text": "缺少实战经验？一键解决！",
        "title": "【专题课：你不知道的硬核数据状态管理】",
        "url": "https://mp.weixin.qq.com/s/k6MblcpoJNaTpVVp5Z0eZA"
      },
      "corp_tag": ["微医"],
      "is_favorite": false,
      "qid": 503,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 一、React中setState后发生了什么\n\n在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。\n\n经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。\n\n在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。\n\n在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。\n\n### 二、setState 为什么默认是异步\n\n假如所有setState是同步的，意味着每执行一次setState时（有可能一个同步代码中，多次setState），都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代码中的多个setState合并成一次组件更新。\n\n### 三、setState 什么时候是同步\n\n在setTimeout或者原生事件中，setState是同步的。",
        "answer": "",
        "biz_type": 1,
        "qid": 503,
        "subject": "",
        "title": "React 中 setState 后发生了什么？setState 为什么默认是异步？setState 什么时候是同步？"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 6,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/reactjinjie.gif",
        "style_tpl": 0,
        "text": "React不熟练怎么办",
        "title": "【专题课：React高级玩家必会指南】",
        "url": "https://mp.weixin.qq.com/s/NrgDKsi8H5SqEK9dVSPFsA"
      },
      "corp_tag": ["海风教育"],
      "is_favorite": false,
      "qid": 549,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 一、React\n\nReactJS是一套JavaScript Web库，由Facebook打造而成且主要用于构建高性能及响应式用户界面。遵循组件设计模式、声明式编程范式和函数式编程概念，以使前端应用程序更高效。它使用虚拟DOM来有效地操作DOM。遵循单向数据流，让状态管理更加可控。\n\nReactJS并不是一个完整的MVC框架，最多可以认为是MVC中的V（View）。在Web开发中，我们需要将变化的数据实时反应到UI上，这时就需要对DOM的操作。而复杂频繁的操作通常是性能瓶颈产生的原因。React为此引入了虚拟DOM（Virtual DOM）的机制：在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新\n\n\n### 二、优点\n\n#### 2.1 React速度快\n\n与其它框架相比，React采取了一种特立独行的操作DOM的方式，它并不直接对DOM进行操作，它引入了一个叫做虚拟DOM的概念，安插在JavaScript逻辑和实际的DOM之间。这一概念提高了Web性能。在UI渲染过程中，React通过在虚拟DOM中的微操作来实对现实际DOM的局部更新\n\n#### 2.2 跨浏览器兼容\n\n虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的\n\n#### 2.3 模块化\n\n程序编写独立的模块化UI组件，这样当某个或某些组件出现问题是，可以方便地进行隔离。\n\n每个组件都可以进行独立的开发和测试，并且它们可以引入其它组件。这等同于提高了代码的可维护性。\n\n#### 2.4 单向数据流\n\nFlux是一个用于在JavaScript应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化。它只是一个概念，而非特定工具的实现。它可以被其它框架吸纳。\n\n#### 2.5 同构的JavaScript\n\n单页面JS应用程序的最大缺陷在于对搜索引擎的索引有很大限制。React对此有了解决方案。\n\nReact可以在服务器上预渲染应用再发送到客户端。它可以从预渲染的静态内容中恢复一样的记录到动态应用程序中。\n\n因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。\n\n### 三、缺点\n\n#### 3.1只是View层\n\nReact本身只是一个V而已，并不是一个完整的框架，所以如果是大型项目想要一套完整的框架的话，基本都需要加上ReactRouter和Flux...才能写大型应用\n\n#### 3.2状态不同步\n\n函数的运行是独立的，每个函数都有一份独立的作用域。函数的变量是保存在运行时的作用域里面，当我们有异步操作的时候，经常会碰到异步回调的变量引用是之前的，也就是旧的（这里也可以理解成闭包）\n\n ```js\nimport React, { useState } from \"react\";\nconst Counter = () => {\n  const [counter, setCounter] = useState(0);\n  const onAlertButtonClick = () => {\n    setTimeout(() => {\n      alert(\"Value: \" + counter);\n    }, 3000);\n  };\n  return (\n    <div>\n      <p>You clicked {counter} times.</p>\n      <button onClick={() => setCounter(counter + 1)}>Click me</button>\n      <button onClick={onAlertButtonClick}>\n        Show me the value in 3 seconds\n      </button>\n    </div>\n  );\n};\nexport default Counter;\n ```\n\n当你点击`Show me the value in 3 seconds`的后，紧接着点击`Click me`使得`counter`的值从0变成1。三秒后，定时器触发，但`alert`出来的是0（旧值），但我们希望的结果是当前的状态1。\n\n这个问题在class component不会出现，因为`class component`的属性和方法都存放在一个`instance`上，调用方式是：`this.state.xxx`和`this.method()`。因为每次都是从一个不变的`instance`上进行取值，所以不存在引用是旧的问题。\n\n**解决**\n\n其实解决这个hooks的问题也可以参照类的`instance`。用`useRef`返回的`immutable RefObject`（`current`属性是可变的）来保存`state`，然后取值方式从`counter`变成了：`counterRef.current`。如下：\n\n```js\nimport React, { useState, useRef, useEffect } from \"react\";\nconst Counter = () => {\n  const [counter, setCounter] = useState(0);\n  const counterRef = useRef(counter);\n  const onAlertButtonClick = () => {\n    setTimeout(() => {\n      alert(\"Value: \" + counterRef.current);\n    }, 3000);\n  };\n  useEffect(() => {\n    counterRef.current = counter;\n  });\n  return (\n    <div>\n      <p>You clicked {counter} times.</p>\n      <button onClick={() => setCounter(counter + 1)}>Click me</button>\n      <button onClick={onAlertButtonClick}>\n        Show me the value in 3 seconds\n      </button>\n    </div>\n  );\n};\nexport default Counter;\n```\n\n结果如我们所期待，`alert`的是当前的值1。\n\n我们可以把这个过程封装成一个`custom hook`，如下：\n\n```js\nimport { useEffect, useRef, useState } from \"react\";\nconst useRefState = <T>(initialValue: T):\n [T, React.MutableRefObject<T>, \n   React.Dispatch<React.SetStateAction<T>>] => {\n  const [state, setState] = useState<T>(initialValue);\n  const stateRef = useRef(state);\n  useEffect(() => {\n    stateRef.current = state;\n  }, [state]);\n  return [state, stateRef, setState];\n};\nexport default useRefState;\n```\n\n尽管这个问题被巧妙地解决了，但它不优雅、`hack`味道浓，且丢失了函数编程风格。\n\n**怎么避免`react hooks`的常见问题**\n\n1. 不要在 `useEffect`里面写太多的依赖项，划分这些依赖项成多个单一功能的 `useEffect`。其实这点是遵循了软件设计的“单一职责模式”。\n\n2. 如果你碰到状态不同步的问题，可以考虑下手动传递参数到函数。如：\n\n```js\n// showCount的count来自父级作用域 \nconst [count,setCount] = useState(xxx); \nfunction showCount(){ \n  console.log(count) \n} \n// showCount的count来自参数 \nconst [count,setCount] = useState(xxx); \nfunction showCount(c){ \n  console.log(c) \n}\n```\n\n但这个也只能解决一部分问题，很多时候你不得不使用上述的`useRef`方案。\n\n3. 重视`eslint-plugin-react-hooks`插件的警告。\n\n4. 复杂业务的时候，使用Component代替`hooks`。\n\n\n### 四、使用过程中遇到的问题，如何解决的？\n\n1. SPA应用，首屏时间过长，可以增加Loading态、骨架屏、异步加载、SSR等方法解决\n2. 父节点状态更新会导致无关子节点也会更新，使用`shouldComponentUpdate`、`PureComponent`、`React.memo` 等方式避免没有必要的渲染\n3. `setState` 并非都是同步执行，所以需要注意 `setState` 的状态更新、多次setState会被忽略等问题；另外object类型的state更新需要注意引用问题\n4. 复杂组件state难于管理难于追踪，应尽量避免使用state，可以使用Redux等方式统一管理state",
        "answer": "",
        "biz_type": 1,
        "qid": 549,
        "subject": "",
        "title": "对 React 的看法，它的优缺点，使用过程中遇到的问题，如何解决的"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 4,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhiyeguihua.gif",
        "style_tpl": 0,
        "text": "前端路上没人带，老走弯路？",
        "title": "【专题课：十年前端老兵亲述：我和前端这十年】",
        "url": "https://mp.weixin.qq.com/s/J4qABCwfd6HyafOLLSgbvQ"
      },
      "corp_tag": ["蘑菇街", "海风教育"],
      "is_favorite": false,
      "qid": 530,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "\n#### 1）编写简单直观的代码\n\nReact最大的价值不是高性能的虚拟DOM、封装的事件机制、服务器端渲染，而是声明式的直观的编码方式。翻开react中文文档，第一条就是声明式，React 使创建交互式 UI 变得轻而易举。为你应用的每一个状态设计简洁的视图，当数据改变时 React 能有效地更新并正确地渲染组件。\n以声明式编写 UI，可以让你的代码更加可靠，且方便调试。\n\n#### 2）简化可复用的组件\n\nReact框架里面使用了简化的组件模型，但更彻底地使用了组件化的概念。React将整个UI上的每一个功能模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成更大的组件。\n\nReact的组件具有如下的特性：\n\n- 可组合：简单组件可以组合为复杂的组件\n- 可重用：每个组件都是独立的，可以被多个组件使用\n- 可维护：和组件相关的逻辑和UI都封装在了组件的内部，方便维护\n- 可测试：因为组件的独立性，测试组件就变得方便很多。\n\n#### 3）Virtual DOM\n\n真实页面对应一个 DOM 树。在传统页面的开发模式中，每次需要更新页面时，都要手动操作 DOM 来进行更新。DOM 操作非常昂贵。我们都知道在前端开发中，性能消耗最大的就是 DOM 操作，而且这部分代码会让整体项目的代码变得难以维护。React 把真实 DOM 树转换成 JavaScript 对象树，也就是 Virtual DOM，每次数据更新后，重新计算 Virtual DOM，并和上一次生成的 Virtual DOM 做对比，对发生变化的部分做批量更新。React 也提供了直观的 shouldComponentUpdate 生命周期回调，来减少数据变化后不必要的 Virtual DOM 对比过程，以保证性能。\n\n#### 4）函数式编程\n\nReact 把过去不断重复构建 UI 的过程抽象成了组件，且在给定参数的情况下约定渲染对应的 UI 界面。React 能充分利用很多函数式方法去减少冗余代码。此外，由于它本身就是简单函数，所以易于测试。\n\n#### 5）一次学习，随处编写\n\n无论你现在正在使用什么技术栈，你都可以随时引入 React 来开发新特性，而不需要重写现有代码。\n\nReact 还可以使用 Node 进行服务器渲染，或使用 React Native 开发原生移动应用。因为 React 组件可以映射为对应的原生控件。在输出的时候，是输出 Web DOM，还是 Android 控件，还是 iOS 控件，就由平台本身决定了。所以，react很方便和其他平台集成\n\n",
        "answer": "",
        "biz_type": 1,
        "qid": 530,
        "subject": "",
        "title": "介绍 React 设计思路，它的理念是什么？"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["寺库"],
      "is_favorite": false,
      "qid": 508,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "\n### 一、热加载\n\n热加载的思想是运行时动态注入修改后的文件内容，同时不中断 APP 的正常运行。这样，我们就不会丢失 APP 的任何状态信息，尤其是 UI 页面栈相关的。\n\n其中关键的区别在于实时加载应用更新时需要刷新当前页面，可以看到明显的全局刷新效果，而热加载基本上看不出刷新的效果，类似于局部刷新。\n\n热加载的基础是模块热替换（HMR，Hot Module Replacement[3]），HMR 最开始是由 Webpack 引入的，而在 React Native Packager 中也实现了这个功能。HMR 使得 Packager 可以监控文件的改动并发送 HMR 更新消息（HMR update）给包含在 APP 中的一层很薄的 HMR 运行时（HMR runtime）。\n\n简而言之，HMR 更新消息包含 JS 模块中发生变化的代码，当 HMR 运行时接收到这个消息，就使用新的代码替换旧的代码。\n\n### 二、热加载方案\n\n#### 借助开源方案\n\n- pushy\n  - 命令行工具&网页双端管理，版本发布过程简单便捷，完全可以集成 CI。\n  - 基于 bsdiff 算法创建的超小更新包，通常版本迭代后在 1-10KB 之间，避免数百 KB 的流量消耗。\n  - 支持崩溃回滚，安全可靠。\n  - meta 信息及开放 API，提供更高扩展性。\n  - 跨越多个版本进行更新时，只需要下载一个更新包，不需要逐版本依次更新\n\n### 三、兼容问题\n\n#### 1、如果无设置具体宽度，部分安卓手机会出现文字超出容器情况。\n\n```js\nlgNormalText: {\n  flex: 1,\n  flexWrap: 'wrap',\n  fontSize: S(28),\n}\n```\n\n解决方法：\n\n给Text或Text容器设置具体宽度，不能使用flex：1\n\n```js\nlgNormalText: {\n  width: S(508),\n  flexWrap: 'wrap',\n  fontSize: S(28),\n}\n```\n\n#### 2、安卓上图片地址无改变时，图片不会刷新。\n\n解决方法：\n\n后台返回新图片地址需是唯一的,前端给图片地址参数加上时间戳\n\n```js\nconst newImageUri = https://www.image.com?a=b&timestamp=${new Date().getTime()}\n```\n\n\n#### 3、官方Switch组件新trackColor属性在部分安卓无效\n\n```js\n<Switch\n  onValueChange={onChange}\n  value={isChecked}\n  style={styles.switchStyle}\n  onTintColor={ButtonColor.SWITCH_BACKGROUND_GREEN} // 忽略警告使用trackColor替换，在安卓无效，暂不替换。\n/>\n```\n解决方法：\n\n使用onTintColor属性\n\n#### 4、TextInput在安卓上默认有padding，IOS没有\n\n解决方法：\n\n安卓上手动将TextInput的padding设置为0\n\n#### 5、在render函数中渲染沉浸式状态栏时，在安卓上总是被原生的状态栏样式渲染覆盖\n\n```js\n<SafeAreaContainer>\n  <KsNavigation navigation={this.props.navigation} navigationTitle={'通知'} />\n  <StatusBar hidden={false} backgroundColor={'#fff'} />\n</SafeAreaContainer>\n```\n\n解决方法：\n\n在组件声明周期componentDidMount中使用StatusBar方法改变状态栏\n\n```js\ncomponentDidMount() {\n  StatusBar.setTranslucent(true);\n  StatusBar.setBackgroundColor('transparent');\n  StatusBar.setBarStyle('light-content');\n}\n```\n\n#### 6、WebView加载本地静态HTML文件时，需要加上baseUrl: ''，否则部分安卓机型会出现文字乱码\n\n```js\n<WebView\n  source={{ html: pointsProductInfo.appIntroduce, baseUrl: '' }}\n/>\n```\n\n#### 7、人民币符号明文使用‘¥’，在部分安卓机型展示会有问题\n\n```js\n<Text>¥</Text>\n```\n\n解决方法：\n\n```js\n<Text>&yen;</Text>\n```\n\n#### 8、Android键盘会把底部的元素顶上去,如下，KsButton会被顶上去\n\n\n解决方法：\n\nKeyboard监听键盘显示/隐藏，动态控制KsButton的隐藏/显示\n\n```js\n<View>\n  <FlatList data={data} renderItem={this.renderItem} />\n  <KsButton text=\"保存\" onPress={this.onPress} />\n</View>\n\nif (isAndroid) {\n  this.keyboardDidShowListener = Keyboard.addListener('keyboardDidShow', () => {});\n  this.keyboardDidHideListener = Keyboard.addListener('keyboardDidHide', () => {});\n}\n```\n\n#### 9、ES6、ES7...等js原生提供的方法，在不同的机型不同版本上支持不同，如flat在iOS12以下不支持，会造成闪退\n\n解决方法：\n\n在Can I use上查询是否支持使用\n\n若有兼容性问题，可使用lodash提供的方法替换\n\n#### 10、Image组件在设置了resizeMode后设置borderRadius在android上无效\n\n```js\n<Image\n  source={image.icon}\n  style={{ borderRadius: 10 }}\n  resizeMode=\"stretch\"\n/>\n```\n\n解决方法：\n\nborderRadius设置在父组件View上\n\n```js\n<View style={{ borderRadius: 10 }}>\n  <Image\n    source={image.icon}\n    resizeMode=\"stretch\"\n  />\n</View>\n```\n\n#### 11、文字设置了加粗后需要设置字体，否则部分Android机型上可能会有不同的表现\n\n解决方法：\n\n增加fontFamily: 'System'\n\n```js\ntitle: {\n  fontWeight: 'bold',\n  fontFamily: 'System',\n}\n```\n\n#### 12、ImageBackground组件设置style样式borderRadius在Android 上无效果\n\n解决方法：\n\n给ImageBackground组件属性imageStyle上设置borderRadius\n\n```js\n<ImageBackground\n   imageStyle={{ borderRadius: xxx }} \n>...</ImageBackground>\n```\n\n#### 13、在react-native ^0.61.1版本上给View设置borderRadius在Android上无效果\n\n解决方法： \n\n给需要设置borderRadius的View组件嵌套在一个带有backgroundColor属性的View组件里\n\n```js\n<View>\n   style={{\n    ...\n backgroundColor: 'rgba(0,0,0,.005)'\n   }}\n>\n  <View style={{\n   ...\n borderRadius: ...\n  }}/>\n</View>\n```\n\n#### 14、在WebView中，IOS获取window.postMessage传递参数时，在onMessage中解析参数需使用双重decodeURIComponent解码\n\n```js\nconst injectedJavaScript = `\n(function () {\n  var height = null;\n  function changeHeight() {\n if (document.body.scrollHeight != height) {\n     height = document.body.scrollHeight;\n      if (window.postMessage) {\n        window.postMessage(JSON.stringify({\n          type: 'setHeight',\n          data: height,\n        }))\n      }\n    }\n  }\n  setTimeout(changeHeight, 500);\n}());`;\n\n<WebView\n  originWhitelist={['*']}\n  source={{ html: pointsProductInfo.appIntroduce, baseUrl: '' }}\n  onMessage={(event) => {\n    try {\n     const eventData = isIOS() ? decodeURIComponent(decodeURIComponent(event.nativeEvent.data)) : event.nativeEvent.data;\n     const action = JSON.parse(eventData);\n     const { type, data } = action;\n     if (Object.prototype.hasOwnProperty.call(this.OnMessageActions, type)) {\n        this.OnMessageActions[type](data);\n     }\n   } catch (error) {\n     console.error('ShowWebViewPage onMessage错误', error);\n   }\n  }}\n/>\n```\n\n#### 2、微信 会屏蔽分享的红包 '元\"等文字 分享的图片不能超过32K\n\n\n\n\n",
        "answer": "",
        "biz_type": 1,
        "qid": 508,
        "subject": "",
        "title": "RN 有没有做热加载？RN 遇到的兼容性问题？"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["头条"],
      "is_favorite": false,
      "qid": 354,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "**设计思想**\n\n在 jQuery 时代的时候，我们是「面向过程开发」，随着 react 的普及，我们提出了状态驱动 UI 的开发模式。我们认为：Web 应用就是状态与 UI 一一对应的关系。\n\n但是随着我们的 web 应用日趋的复杂化，一个应用所对应的背后的 state 也变的越来越难以管理。而 Redux 就是 Web 应用的一个状态管理方案。\n\nRedux是Flux思想的一种实现，同时又在其基础上做了改进。主要体现在：\n\n- 单向的数据流\n- Store是唯一的数据源\n\n**Redux三大原则**\n\n- 单一数据源\n- State 只读\n- 使用纯函数来修改",
        "answer": "",
        "biz_type": 1,
        "qid": 354,
        "subject": "",
        "title": "redux 的设计思想"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 4,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhiyeguihua.gif",
        "style_tpl": 0,
        "text": "前端路上没人带，老走弯路？",
        "title": "【专题课：十年前端老兵亲述：我和前端这十年】",
        "url": "https://mp.weixin.qq.com/s/J4qABCwfd6HyafOLLSgbvQ"
      },
      "corp_tag": ["阿里"],
      "is_favorite": false,
      "qid": 352,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 思考\n\nRedux应该只负责管理共用的状态，如用户信息、登录信息以及一些数据层面上的状态，如时间、天气、购物车、产品列表等。\n\n而针对一些UI级别的状态变化，应该放在组件私有state，这些类别包括：\n\n- UI层面的toggle状态，如展开全部、加载更多等。\n- 为了实现动画而维护的状态值，如拖拽改变组件坐标。\n- 表单中的input的state。\n\n在这个问题中，每块小的组件有自己的状态，那么就把这部分状态放在组件私有state；它们公共的状态将放在Redux中。\n\n",
        "answer": "",
        "biz_type": 1,
        "qid": 352,
        "subject": "",
        "title": "多个组件之间如何拆分各自的 state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，这如何思考"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 2,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhuantaiguanli.gif",
        "style_tpl": 0,
        "text": "缺少实战经验？一键解决！",
        "title": "【专题课：你不知道的硬核数据状态管理】",
        "url": "https://mp.weixin.qq.com/s/k6MblcpoJNaTpVVp5Z0eZA"
      },
      "corp_tag": ["网易"],
      "is_favorite": false,
      "qid": 375,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 实现原理\n\nReact基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。\n\n在React底层，主要对合成事件做了：**事件委派和自动绑定**。\n\n**事件委派:** React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。\n\n**自动绑定:** React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。",
        "answer": "",
        "biz_type": 1,
        "qid": 375,
        "subject": "",
        "title": "React 组件中怎么做事件代理？它的原理是什么？"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["兑吧", "蘑菇街"],
      "is_favorite": false,
      "qid": 481,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 区别\n\n都是存储数据以供后期使用。但是Redux状态更改可回溯——Time travel，数据多了的时候可以很清晰的知道改动在哪里发生，完整的提供了一套状态管理模式。\n\n随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。\n\n管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。\n\n如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等等。前端开发者正在经受前所未有的复杂性，难道就这么放弃了吗？当然不是。\n\n这里的复杂性很大程度上来自于：我们总是将两个难以理清的概念混淆在一起：变化和异步。 可以称它们为曼妥思和可乐。如果把二者分开，能做的很好，但混到一起，就变得一团糟。一些库如 React 视图在视图层禁止异步和直接操作 DOM 来解决这个问题。美中不足的是，React 依旧把处理 state 中数据的问题留给了你。Redux就是为了帮你解决这个问题。",
        "answer": "",
        "biz_type": 1,
        "qid": 481,
        "subject": "",
        "title": "Redux 状态管理器和变量挂载到 window 中有什么区别"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["滴滴"],
      "is_favorite": false,
      "qid": 380,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 区别\n\n从最终渲染的 DOM 来看，这两者都是链接，都是 `<a>` 标签，区别是：\n\n`<Link>` 是 `react-router` 里实现路由跳转的链接，一般配合 `<Route>` 使用，`react-router` 接管了其默认的链接跳转行为，区别于传统的页面跳转，`<Link>` 的“跳转”行为只会触发相匹配的 `<Route>` 对应的页面内容更新，而不会刷新整个页面。\n\n**`<Link>` 做了3件事情:**\n\n1. 有`onclick`那就执行`onclick`\n2. `click`的时候阻止`a`标签默认事件\n3. 根据跳转`href`（即是to），用history（web前端路由两种方式之一，history & hash）跳转，此时只是链接变了，并没有刷新页面\n\n而 `<a>` 标签就是普通的超链接了，用于从当前页面跳转到 `href `指向的另一个页面（非锚点情况）。\n\n### a 标签默认事件禁掉之后做了什么才实现了跳转?\n\n```js\nlet domArr = document.getElementsByTagName('a')\n[...domArr].forEach(item=>{\n    item.addEventListener('click',function () {\n        location.href = this.href\n    })\n})\n```\n\n",
        "answer": "",
        "biz_type": 1,
        "qid": 380,
        "subject": "",
        "title": "react-router 里的 Link 标签和 a 标签有什么区别"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 4,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhiyeguihua.gif",
        "style_tpl": 0,
        "text": "前端路上没人带，老走弯路？",
        "title": "【专题课：十年前端老兵亲述：我和前端这十年】",
        "url": "https://mp.weixin.qq.com/s/J4qABCwfd6HyafOLLSgbvQ"
      },
      "corp_tag": ["有赞"],
      "is_favorite": false,
      "qid": 422,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 分析\n\n我们知道在RN上写的代码最终会打包成jsbundle并被原生加载解析，在打包之前会经过babel把JSX解析为纯js函数，RN上的组件现在都是ReactElement对象。在原生创建好了js线程和加载完jsbundle之后开始执行js代码，而原生到rn世界的入口是我们熟悉的 `AppRegistry.registerComponent` ，在这个方法里一路走可以看到几个主要函数调用是`renderApplication->React.createElement`，RN上的ReactElement调用`React.createElement`渲染，最终调用的是原生模块RCTUIManager的`createView`方法来创建原生组件，通过yoga引擎解析计算组件的布局，最终渲染出对应的原生组件。",
        "answer": "",
        "biz_type": 1,
        "qid": 422,
        "subject": "",
        "title": "RN 为什么能在原生中绘制成原生组件"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 6,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/reactjinjie.gif",
        "style_tpl": 0,
        "text": "React不熟练怎么办",
        "title": "【专题课：React高级玩家必会指南】",
        "url": "https://mp.weixin.qq.com/s/NrgDKsi8H5SqEK9dVSPFsA"
      },
      "corp_tag": ["网易"],
      "is_favorite": false,
      "qid": 372,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 使用redux-saga\n\nredux-saga是一个管理redux应用异步操作的中间件，用于代替 redux-thunk 的。\n\n它通过创建 Sagas 将所有异步操作逻辑存放在一个地方进行集中处理，以此将react中的同步操作与异步操作区分开来，以便于后期的管理与维护。\n\nredux-saga如何处理并发:\n\n#### 1.takeEvery \n\n可以让多个 saga 任务并行被 fork 执行。\n\n```js\nimport {\n    fork,\n    take\n} from \"redux-saga/effects\"\n\nconst takeEvery = (pattern, saga, ...args) => fork(function*() {\n    while (true) {\n        const action = yield take(pattern)\n        yield fork(saga, ...args.concat(action))\n    }\n})\n```\n\n#### 2.takeLatest\n\ntakeLatest 不允许多个 saga 任务并行地执行。一旦接收到新的发起的 action，它就会取消前面所有 fork 过的任务（如果这些任务还在执行的话）。\n\n在处理 AJAX 请求的时候，如果我们只希望获取最后那个请求的响应，takeLatest 就会非常有用。\n\n```js\nimport {\n    cancel,\n    fork,\n    take\n} from \"redux-saga/effects\"\n\nconst takeLatest = (pattern, saga, ...args) => fork(function*() {\n    let lastTask\n    while (true) {\n        const action = yield take(pattern)\n        if (lastTask) {\n            yield cancel(lastTask) // 如果任务已经结束，则 cancel 为空操作\n        }\n        lastTask = yield fork(saga, ...args.concat(action))\n    }\n})\n```",
        "answer": "",
        "biz_type": 1,
        "qid": 372,
        "subject": "",
        "title": "redux 请求中间件如何处理并发"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["头条", "宝宝树"],
      "is_favorite": false,
      "qid": 405,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 一、接入 Redux 过程\n\n1. 安装redux：`npm install redux`\n2. 创建Store 统一管理state：`const store = createStore(reducerFn)`\n3. 通过store，订阅(subscribe)state和分发更新(ddispatch)state\n\n```js\nlet store = createStore(reducerFn);\nstore.subscribe(() => {\n    // do something\n    console.log(store.getState())\n})\nstore.dispatch({type: 'action'})\n```\n\n### 二、绑定 connect 的过程\n\nconnect作用是连接Redux store和React 组件\n\n`connect([mapStateToProps], [mapDispatchToProps], [mergeProps],[options])`\n\n- mapStateToProps：将Redux store中的数据作为props绑定到组件中\n- mapDispatchToProps：讲action作为props绑定到组件上\n- mergeProps：`mapStateToProps`和`mapDispatchToProps`得到的props和ownerProps合并\n- options: 定制connect的一些特殊行为\n\n\n### 三、connect 的原理\n\n1. Provider 向子组件提供store的Context\n2. 接收Redux的store作为props，通过context对象传递给子组件上的connect\n3. connect连接 Redux 和 React，通过高阶组件HOC包在我们的容器组件的外一层，它接收上面 Provider 提供的 store，根据对应转换函数得到 state 和 dispatch，并组成一个对象，以属性形式传给我们的容器组件，并在内部订阅store的变化，根据变化更新state的值。",
        "answer": "",
        "biz_type": 1,
        "qid": 405,
        "subject": "",
        "title": "接入 Redux 过程？绑定 connect 的过程？connect 的原理"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 4,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhiyeguihua.gif",
        "style_tpl": 0,
        "text": "前端路上没人带，老走弯路？",
        "title": "【专题课：十年前端老兵亲述：我和前端这十年】",
        "url": "https://mp.weixin.qq.com/s/J4qABCwfd6HyafOLLSgbvQ"
      },
      "corp_tag": ["有赞", "微医", "58"],
      "is_favorite": false,
      "qid": 423,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 一、什么是虚拟Dom\n\n从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而**有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能**。\n\n虚拟dom是对DOM的抽象，这个对象是更加轻量级的对DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM,如果想实现SSR,那么一个方式就是借助虚拟dom, 因为虚拟dom本身是js对象。\n在代码渲染到页面之前，vue或者react会把代码转换成一个对象（虚拟DOM）。以对象的形式来描述真实dom结构，最终渲染到页面。在每次数据发生变化前，虚拟dom都会缓存一份，变化之时，现在的虚拟dom会与缓存的虚拟dom进行比较。\n\n在vue或者react内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。\n\n另外现代前端框架的一个基本要求就是无须手动操作DOM,一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。\n\n### 二、为什么要用 Virtual DOM\n\n#### 1.保证性能下限，在不进行手动优化的情况下，提供过得去的性能\n\n看一下页面渲染的一个流程：\n\n- 解析HTNL ☞ 生成DOM? ☞ 生成 CSSOM ☞ Layout ☞ Paint ☞ Compiler\n\n下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗：\n\n- 真实DOM： 生成HTML字符串 + 重建所有的DOM元素\n- Virtual DOM： 生成vNode + DOMDiff + 必要的dom更新\n\nVirtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道： **框架给你的保证是，你不需要手动优化的情况下，我依然可以给你提供过得去的性能。**\n\n#### 2.跨平台\n\nVirtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。\n\n### 三、Virtual DOM真的比真实DOM性能好吗\n\n1. 首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。\n2. 正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。\n\n\n",
        "answer": "",
        "biz_type": 1,
        "qid": 423,
        "subject": "",
        "title": "对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？"
      },
      "tech_tag": ["React", "Vue"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 2,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhuantaiguanli.gif",
        "style_tpl": 0,
        "text": "缺少实战经验？一键解决！",
        "title": "【专题课：你不知道的硬核数据状态管理】",
        "url": "https://mp.weixin.qq.com/s/k6MblcpoJNaTpVVp5Z0eZA"
      },
      "corp_tag": ["饿了么"],
      "is_favorite": false,
      "qid": 452,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 一、一个对象数组，每个子对象包含一个 id 和 name，React 如何渲染出全部的 name？在哪个生命周期里写？\n\n可以通过使用 {} 在 JSX 内构建一个元素集合。\n\n```js\nconst userList = [{\n    name: '老王',\n    id: 1\n}, {\n    name: '小王',\n    id: 2\n}]\n\nfunction RenderUser() {\n    return userList.map((item) => {\n        return <span key = {\n            item.id\n        } > {\n            item.name\n        } < /span>\n    })\n}\n\n```\n\n通过ReactDOM.render() 渲染元素\n\n### 二、其中有几个 name 不存在，通过异步接口获取，如何做？\n\n在this.state里定义一个对象，然后接口返回之后，再更新state\n\n如果列表对象里，没有name可以给一个默认值值null\n\n```jsx\nimport React, { Component } from 'react'\n\nexport default class index extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      userList: []\n    }\n  }\n getUserList() {\n    // 模拟获取数据\n    const data = Promise.resolve([{\n      name: '老王',\n      id: 1\n    }, {\n      name: '小王',\n      id: 2\n    }, {\n      id: 3\n    }, {\n      id: 4\n    }])\n    \n    this.setState({\n      userList: data.map((item) => {\n        return {\n          name: null,\n          ...item\n        }\n      })\n    })\n  }\n  componentDidMount() {\n    this.getUserList()\n  }\n  render() {\n    const { userList } = this.state\n    return (\n      <div>\n        {userList.map((item) => {\n          return <span key={item.id}>{item.name}</span>\n        })}\n      </div>\n    )\n  }\n}\n\n```\n\n### 三、渲染的时候 key 给什么值？可以使用 index 吗？用 id 好还是 index 好？\n\nReact高效依赖于所谓的 Virtual-DOM 策略。\n\n简单来说，能复用的话 React 就会尽量复用，没有必要的话绝对不碰 DOM。对于列表元素来说也是这样，但是处理列表元素的复用性会有一个问题：元素可能会在一个列表中改变位置。\n\n例如：\n\n```jsx\n  <div>a</div>\n  <div>b</div>\n  <div>c</div>\n```\n\n改变一下位置\n\n```jsx\n  <div>a</div>\n  <div>c</div>\n  <div>b</div> \n```\n\nReact只需要交换一下 DOM 位置就行了，但是它并不知道其实我们只是改变了元素的位置，所以它会重新渲染后面两个元素（再执行 Virtual-DOM 策略），这样会大大增加 DOM 操作。但如果给每个元素加上唯一的标识，就可以知道这两个元素只是交换了位置\n\n```jsx\n  <div key='a'>a</div>\n  <div key='b'>b</div>\n  <div key='c'>c</div>\n```\n\nReact就简单的通过 key 来判断出来，这两个列表元素只是交换了位置，可以尽量复用元素内部的结构。\n\n对于用表达式套数组罗列到页面上的元素，都要为每个元素加上 key 属性，这个 key 必须是每个元素**唯一**的标识。\n\n一般来说，key 的值可以直接后台数据返回的 id，因为后台的 id 都是唯一的。\n\n对于应的列表渲染：\n\n```jsx\nfunction RenderUser() {\n    return userList.map((item, index) => {\n        return <span key = {\n            item.id\n        } > {\n            item.name\n        } < /span>\n    })\n}\n```\n\n当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key\n\n如果列表项目的顺序可能会变化，我们**不建议**使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。如果你选择不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值。",
        "answer": "",
        "biz_type": 1,
        "qid": 452,
        "subject": "",
        "title": "一个对象数组，每个子对象包含一个 id 和 name，React 如何渲染出全部的 name？在哪个生命周期里写？其中有几个 name 不存在，通过异步接口获取，如何做？渲染的时候 key 给什么值？可以使用 index 吗？用 id 好还是 index 好？"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["阿里"],
      "is_favorite": false,
      "qid": 349,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 一、Redux介绍（数据层框架）\n\nReact是视图层框架\n\nRedux是一个用来管理数据状态和UI状态的JavaScript应用工具。随着JavaScript单页应用（SPA）开发日趋复杂，JavaScript需要管理比任何时候都要多的state（状态），Redux就是降低管理难度的。（Redux支持React，Angular、jQuery甚至纯JavaScript）\n\n如下图所示，在 React 中，UI 以组件的形式来搭建，组件之间可以嵌套组合。但 React 中组件间通信的数据流是单向的，顶层组件可以通过 props 属性向下层组件传递数据，而下层组件不能向上层组件传递数据，兄弟组件之间同样不能。这样简单的单向数据流支撑起了 React 中的数据可控性\n\n![redux-1](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-349-redux-1.png)\n\n当项目越来越大的时候，管理数据的事件或回调函数将越来越多，也将越来越不好管理。管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。\n\n如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等等。state 的管理在大项目中相当复杂。\n\n如下图所示，**Redux 提供了一个叫 `store` 的统一仓储库，组件通过 `dispatch` 将 state 直接传入 store ，不用通过其他的组件。并且组件通过 `subscribe` 从 store 获取到 state 的改变。**\n\n![redux-2](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-349-redux-2.png)\n\nstore 就像一个管理 state 改变的“中间人”，组件之间的信息传递不必直接在彼此间进行，所有的 state 变化都通过 store 这唯一数据源。\n\n ![redux-3](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-349-redux-3.png)\n\n使用了 Redux ，所有的组件都可以从 store 中获取到所需的 state， 他们也能从 store 获取到 state 的改变。这比组件之间互相传递数据清晰明朗的多。\n\n看起来是不是有点像 Flux 。\n\n### 二、Redux的工作流程\n\n![redux-4](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-349-redux-4.png)\n\n图中容易看出所有的东西都是以 store 为核心,我们把它看成数据存储中心,数据银行,但是他要更改数据的时候不能直接修改,数据修改更新的角色由Reducers来担任,\tstore只做存储,中间人,当Reducers的更新完成以后会通过store的订阅来通知react component ,组件把新的状态重新获取渲染,组件中我们也能主动发送action,创建action后这个动作是不会执行的,所以要dispatch这个action,让store通过reducers去做更新React Component 就是react的每个组件。\n\n通俗的理解：\n\n- React Component---人想去贷款创业\n- store ----银行的钱\n- Reducers----银行信贷系统\n- Action Creator----人自己去贷款的动作\n\n你(React Component)想改变自己的经济状况,产生一个去贷款的动作(Action Creato),找到了银行的钱(store),管理员调用信贷系统(Reducers),管理员把钱给你,你变了你的经济状况(更改了状态重新渲染组件)",
        "answer": "",
        "biz_type": 1,
        "qid": 349,
        "subject": "",
        "title": "介绍 Redux 数据流的流程"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 2,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhuantaiguanli.gif",
        "style_tpl": 0,
        "text": "缺少实战经验？一键解决！",
        "title": "【专题课：你不知道的硬核数据状态管理】",
        "url": "https://mp.weixin.qq.com/s/k6MblcpoJNaTpVVp5Z0eZA"
      },
      "corp_tag": ["有赞"],
      "is_favorite": false,
      "qid": 417,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 一、React异步渲染\n\n异步渲染也就是 Concurrent 模式，Concurrent 模式是一组 React 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。\n\n首先，我们需要从浏览器的工作原理去入手，众所周知，JS 是单线程的，但浏览器内核则是多线程的，除了 JS 线程外，它还包含 UI 渲染线程、事件处理线程等等，浏览器是按帧进行刷新的，一帧里面会完成包括 事件接收、JS 运行、布局、重绘 等任务，对于 JS 线程与 UI 渲染线程而言，他们是互斥的，必须 JS 运行完成（变更 DOM、修改样式）后 UI 线程才去进行渲染，而对于浏览器事件，发生后事件线程会事件添加到任务队列的末尾，等待 JS 线程的处理。\n\n联想下平时研发的应用，你会感觉页面很卡顿，键盘输入、鼠标点击都无法快速响应，这是为什么？是因为当前 JS 一直在执行，渲染帧大量被 JS 运行占据，导致无法进行渲染的工作，因此掉帧，同样的 JS 线程没有余力去处理队尾的事件，因此输入点击也没有效果了。\n\nConcurrent 就是为了解决这样的场景，它的本质，或者说 Concurrent 与 non-Concurrent 的区别在什么地方，就是它给 JS 运行加了一道\"刹车\"，non-Concurrent 模式下，一次更新发生 JS 运行必须一次性完成，没有商量的余地。而在 Concurrent 模式下就不是这样了，它会最大程度地利用渲染帧的时间来运行 JS，也就是一个时间片，时间片一过，OK，乖乖地结束 JS 的运行，让 UI 线程进行渲染，对事件进行处理。等下一个时间片到来后，事件可能会生成一些高优先级任务，对现有任务排个序，让这些高优先级的任务先运行，用户也就能很快看到对应的变更结果了，以此来解决一些体验问题。你可以认为这是一种”插队“行为，在 non-Concurrent 模式下，一切 JS 运行是连续并且顺序的，而在 Concurrent 模式下使 JS “变得” 可中断、可恢复、可以设置优先级的。\n\n### 二、Time Slicing\n\n得益于fiber，使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得react能在性能极其差的机器跑时，仍然保持有良好的性能。\n\n- React 在渲染时，不阻塞现在的线程;\n- 如果你的设备足够快，你会感觉渲染是同步的\n- 如果你设备非常慢，你会感觉还算是灵敏的\n- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来\n- 同样书写组件的方式\n\n### 三、Suspence\n\n功能想解决从react出生到现在都存在的「异步副作用」的问题，而且解决得非常的优雅，使用的是「异步但是同步的写法」。\n\n- 引入新的api，可以使得任何state更新暂停，直到条件满足时，再渲染（像async/await）\n- 可以在任何一个组件里放置异步获取数据，而不用做多余的设置\n- 在网速非常快的时候，可设置，整个数据到达Dom，更新完毕以后再渲染\n- 在网速非常慢的时候，可设置，精确到单个组件的等待、以及更新，然后再渲染\n- 会给我们提供 high-level (createFetcher)和 low-level( Placeholder, Loading ) 的 API，可以供给业务代码和一些小组件的书写。\n",
        "answer": "",
        "biz_type": 1,
        "qid": 417,
        "subject": "",
        "title": "react 异步渲染的概念,介绍 Time Slicing 和 Suspense"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["网易"],
      "is_favorite": false,
      "qid": 379,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "\n### 数据检查\n\nangular有脏检查机制，Vue通过Object.defineProporty来劫持对象的get，set方法，实现双向绑定。\n\n相比较react而言，react是单向数据流动的ui渲染框架，本身不存在数据的检测这一机制，所有的数据改变都是通过setState来手动实现的。\n\nReact 本身不具备数据检查的功能（ 这里指双向绑定的特点 ），但是在遇到组件更新时会在 shouldComponentUpdate 这个生命周期函数中进行进行数据检查的相关操作（ 即本次更新是否返回新的状态 ）\n\nReact 响应数据的变化主要是通过生成新的虚拟 dom ，再将其映射为真实的 Dom 树构建完成来生成新的页面\n\nReact 的数据是不可变的，通过 this.setState 或者 Hook 的 setState，会生成新的数据，而不会去做数据检查。\n\n新生成的数据，生成新的虚拟 dom，与 旧的虚拟 dom 通过 diff 算法进行对比，然后确定需要更新的部分。",
        "answer": "",
        "biz_type": 1,
        "qid": 379,
        "subject": "",
        "title": "React 怎么做数据的检查和变化"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["有赞"],
      "is_favorite": false,
      "qid": 418,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "\n### 在以下声明周期中处理\n\n- `static getDerivedStateFromProps()`：返回一个对象用于更新state，返回null则不更新\n- `shouldComponentUpdate()`：根据返回值，判断React组件是否受props变化影响\n- `getSnapshotBeforeUpdate()`：在最近一次渲染输出（提交到DOM节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如滚动位置）。\n- `componentDidUpdate()`：可以对比props变化，也可以执行一些网络请求",
        "answer": "",
        "biz_type": 1,
        "qid": 418,
        "subject": "",
        "title": "16.X 中 props 改变后在哪个生命周期中处理"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 6,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/reactjinjie.gif",
        "style_tpl": 0,
        "text": "React不熟练怎么办",
        "title": "【专题课：React高级玩家必会指南】",
        "url": "https://mp.weixin.qq.com/s/NrgDKsi8H5SqEK9dVSPFsA"
      },
      "corp_tag": ["滴滴"],
      "is_favorite": false,
      "qid": 391,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "\n### 一、内部经历的变化\n\n1. setState引起状态变化\n2. React重新构建vnode树\n3. 和旧vnode树对比，得出变化部分Patches(diff算法)\n4. 将Patches更新到真实dom上\n\n下面再来看下React中的diff算法和渲染过程\n\n### 二、React中的diff算法和渲染过程\n\n#### 2.1 React的简单工作过程\n\n先了解一下React是如何工作的\n\n```js\nvar MyComponent = React.createClass({\n    render: function() {\n        if(this.props.first) {\n            return\n                <div className=\"first\">\n                <span>A Span</span>\n                </div>;\n        } \n        else {\n            return \n                <div className=\"second\">\n                <p> A paragraph </p>      \n                </div>;\n        }\n    }\n});\n```\n\n在任何时候，你都会描述你想要的界面。理解render的结果并不是真正的DOM节点是很重要。这些只是轻量级的javaScript对象。我们称之为虚拟DOM（Virtual DOM）\n\nReact将使用这种表示方法尝试从一个渲染结果切换到另一个渲染结果的最少步数。例如，从 `<MyComponent first={true} />` 开始，然后替换`<MyComponent first={false} />`，最后将它们都删除。\n\n![img](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-391-1.png)\n\n**1）初始renderA**\n\n- 创建节点：`<div className=\"first\"><span>A Span</span></div>`\n- 生命周期：Mounting\n\n**2）再次renderB**\n\n- 比较父节点div =>相同，跳过 进行下面操作\n- 比较父节点div属性=>不相同,下面进行替换属性操作\n    - 替换属性：替换`className=\"first\"`为`className=\"second\"`\n- 比较子节点=>不相同，下面进行子节点替换操作\n    - 替换节点：删除`<span>A Span</span>` 插入`<p>A Paragraph</p>`\n- 生命状态：Updating\n\n**3) 移除节点**\n\n- 移除节点：直接移除div父节点即可，子节点也会被完全删除`<div className=\"second\"><p>A Paragraph</p></div>`\n- 生命周期：Unmounting\n\n#### 2.2 实现细节\n\n##### 2.2.1不同节点类型的比较\n\n为了在树之间进行比较，我们首先要能够比较两个节点，在React中即比较两个虚拟DOM节点，当两个节点不同时，应该如何处理。这分为两种情况：\n\n**1）节点类型不同**\n\n```js\nrenderA: <span />\nrenderB: <p />\n=> [removeNode <span />], [insertNode <p />]\n```\n\n当在树中的同一位置前后输出了不同类型的节点，React直接删除前面的节点，然后创建并插入新的节点。\n\n**2）节点类型相同，但是属性不同**\n\n第二种节点的比较是相同类型的节点，算法就相对简单而容易理解。React会对属性进行重设从而实现节点的转换。例如：\n\n```js\nrenderA: <div className=\"first\" />\nrenderB: <div className=\"second\" />\n=> [replaceAttribute className second]\n```\n\n虚拟DOM的style属性稍有不同，其值并不是一个简单字符串而必须为一个对象，因此转换过程如下：\n\n```js\nrenderA: <div style={{color: 'red'}} />\nrenderB: <div style={{fontWeight: 'bold'}} />\n=> [removeStyle color], [addStyle font-weight 'bold']\n```\n\n##### 2.2.2逐层进行节点比较\n\n查找任意两棵树之间最少修改数的时间复杂度是O(n^3)。可以想象到，这很难处理。\n\nReact使用一种简单但强大的启发式方式来优化到了接近O(n)。\n\nReact只会按层比较两棵树。这样就显著的降低了问题的复杂度，并且由于Web应用中很少将一个组件在不同层之间的移动，从而产生太多负面影响。Web应用通常只会在子节点之间横向移动\n\n![img](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-391-2.png)\n\n例如，考虑有下面的DOM结构转换\n\n![img](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-391-3.png)\n\nA节点被整个移动到D节点下，直观的考虑DOM Diff操作应该是\n\n```js\nA.parent.remove(A); \nD.append(A);\n```\n\n但因为React只会简单的考虑同层节点的位置变换，对于不同层的节点，知识简单的创建和删除。当根节点发现子节点A不见了，就会直接销毁A;而当D发现自己多了一个子节点Ａ，则会创建一个新的Ａ作为子节点。因此对于这种结构的转变的实际操作是：\n\n```js\nA.destroy();\nA = new A();\nA.append(new B());\nA.append(new C());\nD.append(A);\n```\n\n可以看到，以A为根节点的树被整个重新创建。\n\n虽然看上去这样的算法有些“简陋”，但是其基于的是第一个假设：两个不同组件一般产生不一样的DOM结构。根据React官方博客，这一假设至今为止没有导致严重的性能问题。这当然也给我们一个提示，在实现自己的组件时，保持稳定的DOM结构会有助于性能的提升。例如，我们有时可以通过CSS隐藏或显示某些节点，而不是真的移除或添加DOM节点。\n\n##### 2.2.3列表节点的比较\n\n上面介绍了对于不在同一层的节点的比较，即使他们完全一样，也会销毁并重新创建.那么当它们在同一层时，又是如何处理的呢？这就涉及到列表节点的Diff算法。相信很多使用React的同学大多遇到过这样的警告：\n\n![img](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-391-4.png)\n\n这是React在遇到列表时却又找不到key时提示的警告。虽然无视这条警告大部分界面也会正确工作，但这通常意味着潜在的性能问题。因为React觉得自己可能无法高效地去更新这个列表\n\n列表节点的操作通常包括添加、删除和排序。例如下图，我们需要往B和C直接插入节点F，在jQuery中我们可能会直接使用$(B).after(F)来实现。而在React中，我们只会告诉React新的界面应该是A-B-F-C-D-E，由Diff算法完成更新界面。\n\n![img](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-391-5.png)\n\n这时如果每个节点都没有唯一的标识，React无法识别每一个节点，那么更新过程会很低效，即，将C更新成F，D更新成C，E更新成D，最后再插入一个E节点。效果如下图所示：\n\n![img](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-391-6.png)\n\n可以看到，React会逐个对节点进行更新，转换到目标节点。而最后插入新的节点E，涉及到的DOM操作非常多。diff总共就是移动、删除、增加三个操作，而如果给每个节点唯一的标识（key），那么React优先采用移动的方式，能够找到正确的位置去插入新的节点，如下图所示：\n\n![img](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-391-7.png)\n\n对于列表节点顺序的调整其实也类似于插入或删除，下面结合示例代码我们看下其转换的过程。仍然使用前面提到的示例，我们将树的形态从shape5转换到shape6：\n\n![img](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-391-8.png)\n\n题外话：如果你之前接触vue.js，那么你将会很容易理解这个所谓的key，在vue.js中组件复用中使用的就是这个key,如果你对vue.js也敢兴趣的话，请自行去Vue.js官方网站进行学习\n\n#### 2.2.4 组件的比较\n\nReact应用一般由许多用户定义的组件构成。这些组件最终会转换为一个主要由div组成的树。这些附加信息被diff算法利用了。React只会匹配类型相同的组件。\n\n`如果一个<Header>被<Other>替换`，React将删除Header组件然后创建一个Other组件。我们不需要花费宝贵的时间来匹配两个不一样的组件。\n\n![img](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-391-9.png)\n\n##### 2.2.5 事件代理\n\n给DOM节点增加事件监听器是一个既慢又消耗内存的事情。React实现了一个叫“事件代理”的技术，并且重新实现了一个W3C兼容的事件系统。因此使得IE 8的事件处理不再是一个问题，所有的事件都能够跨浏览器使用。\n\n下面让我解释一下它的实现。首先将单个事件监听器添加到文档的根节点上。当事件被触发后，浏览器给出目标DOM节点。为了在整个DOM树上传递事件。React不是在虚拟DOM进行迭代，而是利用每个React组件的唯一ID。我们可以使用一个简单的字符串来获取所有父节点的ID。通过将事件监听器存储在一个Hash表中，我们发现比将事件添加到虚拟DOM效率更高。下面是事件在虚拟DOM中分发的过程。\n\n```js\n//dispatchEvent('click', 'a.b.c', event)\nclickCaptureListeners['a'](event);\nclickCaptureListeners['a.b'](event);\nclickCaptureListeners['a.b.c'](event);\nclickBubbleListeners['a.b.c'](event);\nclickBubbleListeners['a.b'](event);\nclickBubbleListeners['a'](event);\n```\n浏览器为每个事件和监听器创建一个新的事件对象。该对象有一个原始事件对象的引用，并且能够进行修改。这样做会占用更多的内存，因此React专门为这些对象创建了一个对象池。当需要一个事件对象时，直接从对象池中重用。这样显著的降低了垃圾回收。\n\n##### 2.2.5 渲染批处理\n\n当需要调用一个组件的setState时，React将它标记为脏节点。在事件循环的最后才重新渲染所有的脏节点\n\n这种批处理意味着在一个事件循环event-loop，准确地说是一次事件循环中对DOM进行更新。这个特性对构建高性能的JavaScript应用一般来说非常难。但在React中，我们默认就可以利用这个特性。\n\n![img](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-391-10.png)\n\n##### 2.2.6 渲染子树\n\n当调用setState时，组件会重建子节点的虚拟DOM。如果在根元素上通用setState，整个React应用都会被重新渲染。所有的组件，包括没有发生改变的组件都会调用自己的render方法。这样做效率低的相当可怕，但在实际应用的时候还是可以很好的工作的。因为我们不需要直接操作DOM\n\n首先，我们讨论的是如何显示用户界面。因为屏幕空间的限制，我们通常需要一次性按顺序显示成千上完个元素。由于整个界面都可以管理，JavaScript能够足够快地处理业务逻辑\n\n其次，在编写React代码时，我们不需要在每次发生改变后就调用根元素的setState方法。我们只需要在接收到改变事件的节点或者它的一些上层节点调用该方法，很少需要上溯到顶部。这意味着变化被局限在用户交互的地方\n\n![img](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-391-11.png)\n\n##### 2.2.7 选择性渲染子树\n\n最后，我们还能够组件一些子树的重新渲染。如果一个组件实现了下面的方法\n\n```js\nboolean shouldComponentUpdate(object nextProps, object nextState)\n```\n\n我们可以基于组件之前的状态或者下一个状态决定它是否需要重新渲染。如果实现合理的话，这样做能够极大的提高程序的性能\n\n为了使用这个功能，我们需要能够比较JavaScript对象。但比较爱哦的时候又会引发许多事情，比如是“深比较”还是“浅比较”，是否应该使用不可变数据结构或深拷贝\n\n需要注意的是，这个方法会不断调用，因此需要确保它的计算尽可能耗时较少。\n\n![img](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-391-12.png)\n\n##### 2.2.7 总结\n\n这种技术能够使React变得更快已经不是一件新鲜事。我们也已经知道，DOM的处理非常耗时、应该批量进行读写操作、时间处理效率更高...\n\n大家现在还经常讨论他们，因为在正常的JavaScript代码中很难达到这些目标。React让这些优化默认就会发生，高性能应用的开发变得更简单\n\nReact的性能模型非常易于理解：每个setState重新渲染一棵子树。如果想尽量压榨性能，应该尽可能减少调用setState或使用shouldComponentUpdate阻止重新渲染大的子树",
        "answer": "",
        "biz_type": 1,
        "qid": 391,
        "subject": "",
        "title": "React 中 Dom 结构发生变化后内部经历了哪些变化"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 6,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/reactjinjie.gif",
        "style_tpl": 0,
        "text": "React不熟练怎么办",
        "title": "【专题课：React高级玩家必会指南】",
        "url": "https://mp.weixin.qq.com/s/NrgDKsi8H5SqEK9dVSPFsA"
      },
      "corp_tag": ["滴滴"],
      "is_favorite": false,
      "qid": 394,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "\n### 一、Redux中间件\n\nRedux 的中间件提供的是位于 action 被发起之后，到达 reducer 之前的扩展点，换而言之，原本 `view -> action -> reducer -> store` 的数据流加上中间件后变成了 `view -> action -> middleware -> reducer -> store` ，在这一环节我们可以做一些 “副作用” 的操作，如异步请求、打印日志等。\n\n#### 1.applyMiddleware源码\n\n```js\nexport default function applyMiddleware(...middlewares) {\n    return createStore => (...args) => {\n        // 利用传入的createStore和reducer和创建一个store\n        const store = createStore(...args)\n        let dispatch = () => {\n            throw new Error()\n        }\n        const middlewareAPI = {\n            getState: store.getState,\n            dispatch: (...args) => dispatch(...args)\n        }\n        // 让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍\n        const chain = middlewares.map(middleware => middleware(middlewareAPI))\n        // 接着 compose 将 chain 中的所有匿名函数，组装成一个新的函数，即新的 dispatch\n        dispatch = compose(...chain)(store.dispatch)\n        return {\n            ...store,\n            dispatch\n        }\n    }\n}\n```\n\n#### 2.一个简单的中间件\n\n```js\n// 一个打印日志的中间件\nconst logger = store => next => action => {\n    console.log('dispatching', action)\n    let result = next(action)\n    console.log('next state', store.getState())\n    return result\n}\n```\n\n### 二、接受几个参数？柯里化函数两端的参数具体是什么东西？\n\n从applyMiddleware中可以看出：\n\n1. redux中间件接受一个对象作为参数，对象的参数上有两个字段 dispatch 和 getState，分别代表着 Redux Store 上的两个同名函数。\n2. 柯里化函数两端一个是 `middlewares`，一个是 `store.dispatch`",
        "answer": "",
        "biz_type": 1,
        "qid": 394,
        "subject": "",
        "title": "Redux 中间件是什么东西？接受几个参数？柯里化函数两端的参数具体是什么东西？"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 2,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhuantaiguanli.gif",
        "style_tpl": 0,
        "text": "缺少实战经验？一键解决！",
        "title": "【专题课：你不知道的硬核数据状态管理】",
        "url": "https://mp.weixin.qq.com/s/k6MblcpoJNaTpVVp5Z0eZA"
      },
      "corp_tag": ["滴滴"],
      "is_favorite": false,
      "qid": 395,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "\n### Redux 中间件\n\n1. redux中间件本质就是一个函数柯里化；\n2. redux applyMiddleware Api 源码,中 每个 middleware 接受2个参数， Store 的getState 函数和dispatch 函数，分别获得store和action，最终返回一个函数。\n3. 该函数会被传入 next 的下一个 middleware 的 dispatch 方法，并返回一个接收 action 的新函数，这个函数可以直接调用 next(action)，或者在其他需要的时刻调用，甚至根本不去调用它。\n4. 调用链中最后一个 middleware 会接受真实的 store 的 dispatch 方法作为 next 参数，并借此结束调用链。\n5. 所以，middleware 的函数签名是 `({ getState, dispatch }) => next => action`。",
        "answer": "",
        "biz_type": 1,
        "qid": 395,
        "subject": "",
        "title": "Redux 中间件· 中间件是怎么拿到 store 和 action？然后怎么处理？"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["阿里", "滴滴"],
      "is_favorite": false,
      "qid": 347,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "\n\n### 如何配置 `react-router` 实现路由切换：\n\n#### 1.使用 `<Route>` 组件\n\n路由匹配是通过比较 `<Route>` 的 `path` 属性和当前地址的 `pathname` 来实现的。当一个 `<Route>` 匹配成功时，它将渲染其内容，当它不匹配时就会渲染 `null`。没有路径的 `<Route>` 将始终被匹配。\n\n```js\n// when location = { pathname: '/about' }\n<Route path='/about' component={About}/> // renders <About/>\n<Route path='/contact' component={Contact}/> // renders null\n<Route component={Always}/> // renders <Always/>\n```\n\n#### 2.结合使用 `<Switch>` 组件和 `<Route>` 组件\n\n`<Switch>` 用于将 `<Route>` 分组。\n\n```js\n<Switch>\n    <Route exact path=\"/\" component={Home} />\n    <Route path=\"/about\" component={About} />\n    <Route path=\"/contact\" component={Contact} />\n</Switch>\n```\n\n`<Switch>` 不是分组 `<Route>` 所必须的，但他通常很有用。 一个 `<Switch>` 会遍历其所有的子 `<Route>` 元素，并仅渲染与当前地址匹配的第一个元素。\n\n#### 3.使用 `<Link>`、`<NavLink>`、`<Redirect>` 组件\n\n`<Link>` 组件来在你的应用程序中创建链接。无论你在何处渲染一个 `<Link>` ，都会在应用程序的 HTML 中渲染锚 （`<a>`）。\n\n```js\n<Link to=\"/\">Home</Link>\n// <a href='/'>Home</a>\n```\n\n`<NavLink>` 是一种特殊类型的 `<Link>` 当它的 `to` 属性与当前地址匹配时，可以将其定义为“活跃的”。\n\n```js\n// location = { pathname: '/react' }\n<NavLink to=\"/react\" activeClassName=\"hurray\">\n    React\n</NavLink>\n// <a href='/react' className='hurray'>React</a>\n```\n\n当你想强制导航时，你可以渲染一个 `<Redirect>`。当一个 `<Redirect>` 渲染时，它将使用它的 `to` 属性进行定向。",
        "answer": "",
        "biz_type": 1,
        "qid": 347,
        "subject": "",
        "title": "如何配置 React-Router 实现路由切换"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 4,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhiyeguihua.gif",
        "style_tpl": 0,
        "text": "前端路上没人带，老走弯路？",
        "title": "【专题课：十年前端老兵亲述：我和前端这十年】",
        "url": "https://mp.weixin.qq.com/s/J4qABCwfd6HyafOLLSgbvQ"
      },
      "corp_tag": ["滴滴"],
      "is_favorite": false,
      "qid": 392,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "\n\n### 一、textComponent、composeComponent、domComponent，区别和关系\n\nReact 挂载的时候都会进进入一个 mount 函数，然后判断挂载 vnode 的类型，然后，根据 vnode 的类型调用不同函数。\n\n模拟代码：\n\n``` js\nfunction mount(vnode, container) {\n    const { flags } = vnode\n    if (flags === 'dom') {\n        // 挂载普通原生标签 domComponent\n        mountElement(vnode, container)\n    } else if (flags === 'component') {\n        // 挂载组件 composeComponent\n        mountComponent(vnode, container)\n    } else if (flags === 'text') {\n        // 挂载纯文本 textComponent\n        mountText(vnode, container)\n    }\n    ...省略...\n    ...省略...\n}\n```\n\n挂载这三个组件的时候，挂载函数都接受两个参数，vnode 和 container\n\n#### 1.1 挂载 textComponent\n\n``` js\nfunction mountText(vnode, container) {\n    const el = document.createTextNode(vnode.children);\n    vnode.el = el;\n    container.appendChild(el);\n}\n```\n\n纯文本类型的 VNode 其 children 属性存储着与之相符的文本字符串，所以只需要调用 document.createTextNode 函数创建一个文本节点即可，然后将其添加到 container 中。\n\n#### 1.2 挂载 domComponent\n\n模拟代码：\n\n``` js\nfunction mountElement(vnode, container) {\n    const el = document.createElement(vnode.tag);\n    //引用dom元素\n    vnode.el = el;\n    // 把VNodeData 应用到真实DOM元素上\n    const data = vnode.data;\n    if (data) {\n        // 如果 VNodeData 存在，则遍历之\n        for (let key in data) {\n            // key 可能是 class、style、on 等等\n            switch (key) {\n                case \"style\":\n                    // 如果 key 的值是 style，说明是内联样式，逐个将样式规则应用到 el\n                    for (let k in data.style) {\n                        el.style[k] = data.style[k];\n                    }\n                    break;\n                    //处理class\n                case \"class\":\n                    el.className = data[key];\n                    break;\n                default:\n                    if (key[0] === \"o\" && key[1] === \"n\") {\n                        // 绑定事件\n                        el.addEventListener(key.slice(2), data[key]);\n                    } else {\n                        el.setAttribute(key, data[key]);\n                        break;\n                    }\n            }\n        }\n    }\n    // 递归挂载子节点、子节点有很多种类型，所以需要调用mount\n    if (vnode.children) {\n        for (let i = 0; i < vnode.children.length; i++) {\n            mount(vnode.children[i], el);\n        }\n    }\n    container.appendChild(el);\n}\n```\n\nreact 挂载 domComponent 主要做以下几件事：\n\n1. 引用真实的 dom 元素\n2. 将 VNodeData 应用到真实 DOM 元素，如：style、class、事件等\n3. 递归挂载子节点\n\n#### 1.3 挂载 composeComponent\n\n挂载组件是有两种类型，一种是函数组件，一种是有状态组件，他们的产出都是 vnode\n\n模拟代码：\n\n``` js\nfunction mountComponent(vnode, container) {\n    if (vnode.flags & VNodeFlags.COMPONENT_STATEFUL) {\n        mountStatefulComponent(vnode, container);\n    } else {\n        mountFunctionalComponent(vnode, container);\n    }\n}\n```\n\n**1）挂载有状态组件**\n\n模拟代码：\n\n``` js\nfunction mountStatefulComponent(vnode, container) {\n    // 创建组件实例\n    const instance = new vnode.tag();\n    // 渲染VNode\n    instance.$vnode = instance.render();\n    // 挂载\n    mount(instance.$vnode, container);\n    // el 属性值 和 组件实例的 $el 属性都引用组件的根DOM元素\n    instance.$el = vnode.el = instance.$vnode.el;\n}\n```\n\n1. 第一步：创建组件实例，如果一个 VNode 描述的是有状态组件，那么 vnode.tag 属性值就是组件类的引用，所以通过 new 关键字创建组件实例。\n2. 第二步：获取组件产出的 VNode，一个组件的核心就是其 render 函数，通过调用 render 函数可以拿到该组件要渲染的内容。\n3. 第三步：mount 挂载，既然已经拿到了 VNode，那么就将其挂载到 container 上就可以了。\n4. 第四步：让组件实例的 $el 属性和 vnode.el 属性的值引用组件的根 DOM 元素\n\n**2）挂载函数组件**\n\n模拟代码：\n\n``` js\nfunction mountFunctionalComponent(vnode, container) {\n    // 获取 VNode\n    const $vnode = vnode.tag()\n    // 挂载\n    mount($vnode, container)\n    // el 元素引用该组件的根元素\n    vnode.el = $vnode.el\n}\n```\n\n### 二、Dom 结构发生变化时怎么区分 data 的变化，怎么更新，更新怎么调度\n\nReact将DOM抽象为虚拟DOM, 然后通过新旧虚拟DOM 这两个对象的差异(Diff算法), 最终只把变化的部分重新渲染。\n\nReact策略：\n\n1. 两个不同类型的元素会产生不同的树\n2. 对于同一层级的一组节点，他们可以通过唯一的key进行区分\n\n#### 2.1 区分变化\n\n当data（虚拟dom）发生变化时，会先会对新旧两棵树进行diff：\n\n  1. 发现如果是在同一层交换位置，React通过key来判断，如果相同的就会复用节点。\n  2. 如果层级发生了变化，就会重新渲染\n\n#### 2.2更新，调度\n\n新旧两棵树比较后会产生一个差异对象，React就会对这个差异对象更新。\n\n在react16之后使用fiber来实现调度：\n\n出现更新时，fiber会新建一个任务，把任务放到任务队列中，循环执行任务队列中的任务，执行完所有工作中的fiber后，react进入提交步骤，更新dom\n\n### 三、如果更新的时候还有其他任务存在怎么处理？\n\n每一任务都会有创建的时候都会有一个优先级，当遇到有其他任务的时候，先判断是否有优先级更高的任务需要执行，如果有，则中断当前任务，执行更高的优先级任务。\n",
        "answer": "",
        "biz_type": 1,
        "qid": 392,
        "subject": "",
        "title": "React 挂载的时候有 3 个组件，textComponent、composeComponent、domComponent，区别和关系，Dom 结构发生变化时怎么区分 data 的变化，怎么更新，更新怎么调度，如果更新的时候还有其他任务存在怎么处理"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 2,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhuantaiguanli.gif",
        "style_tpl": 0,
        "text": "缺少实战经验？一键解决！",
        "title": "【专题课：你不知道的硬核数据状态管理】",
        "url": "https://mp.weixin.qq.com/s/k6MblcpoJNaTpVVp5Z0eZA"
      },
      "corp_tag": ["脉脉", "兑吧", "寺库", "蘑菇街", "百分点"],
      "is_favorite": false,
      "qid": 225,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "**1）原理**\n\nRedux源码主要分为以下几个模块文件\n\n- compose.js 提供从右到左进行函数式编程\n- createStore.js 提供作为生成唯一store的函数\n- combineReducers.js 提供合并多个reducer的函数，保证store的唯一性\n- bindActionCreators.js 可以让开发者在不直接接触dispacth的前提下进行更改state的操作\n- applyMiddleware.js  这个方法通过中间件来增强dispatch的功能\n\n```js\nconst actionTypes = {\n    ADD: 'ADD',\n    CHANGEINFO: 'CHANGEINFO',\n}\n\nconst initState = {\n    info: '初始化',\n}\n\nexport default function initReducer(state=initState, action) {\n    switch(action.type) {\n        case actionTypes.CHANGEINFO:\n            return {\n                ...state,\n                info: action.preload.info || '',\n            }\n        default:\n            return { ...state };\n    }\n}\n\nexport default function createStore(reducer, initialState, middleFunc) {\n\n    if (initialState && typeof initialState === 'function') {\n        middleFunc = initialState;\n        initialState = undefined;\n    }\n\n    let currentState = initialState;\n\n    const listeners = [];\n\n    if (middleFunc && typeof middleFunc === 'function') {\n        // 封装dispatch \n        return middleFunc(createStore)(reducer, initialState);\n    }\n\n    const getState = () => {\n        return currentState;\n    }\n\n    const dispatch = (action) => {\n        currentState = reducer(currentState, action);\n\n        listeners.forEach(listener => {\n            listener();\n        })\n    }\n\n    const subscribe = (listener) => {\n        listeners.push(listener);\n    }\n\n    return {\n        getState,\n        dispatch,\n        subscribe\n    }\n}\n```\n\n**2）工作流程**\n\n1. const store = createStore(fn)生成数据;\n2. action: {type: Symble('action001'), payload: 'payload' }定义行为;\n3. dispatch发起action: store.dispatch(doSomething('action001'));\n4. reducer: 处理action, 返回新的state;\n\n通俗点解释\n\n1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法\n2. 然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State\n3. State一旦有变化，Store就会调用监听函数，来更新View\n\n",
        "answer": "",
        "biz_type": 1,
        "qid": 225,
        "subject": "",
        "title": "说一下 Redux 的原理，介绍下整体的一个工作流程"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 4,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhiyeguihua.gif",
        "style_tpl": 0,
        "text": "前端路上没人带，老走弯路？",
        "title": "【专题课：十年前端老兵亲述：我和前端这十年】",
        "url": "https://mp.weixin.qq.com/s/J4qABCwfd6HyafOLLSgbvQ"
      },
      "corp_tag": ["高德"],
      "is_favorite": false,
      "qid": 202,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 一、有状态组件\n\n#### 1.特点\n\n- 是一个类组件\n- 有继承\n- 可以使用this\n- 可以使用react的生命周期\n- 使用较多，容易频繁触发生命周期钩子函数，影响性能\n- 内部使用 `state`，维护自身状态的变化，有状态组件根据外部组件传入的 `props` 和自身的 `state` ，进行渲染。\n\n#### 2.使用场景\n\n- 需要使用到状态的\n- 需要使用状态操作组件的（无状态组件的也可以实现 新版本react hooks也可实现）\n\n### 3.总结\n\n类组件可以维护自身的状态变量，即组件的 `state`，类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。\n\n类组件则既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可称为无状态组件。\n\n### 二、无状态组件\n\n#### 1.特点\n\n- 不依赖自身的状态state。\n- 可以是类组件或者函数组件。\n- 可以完全避免使用 this 关键字。(由于使用的是箭头函数事件无需绑定)\n- 有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态函数组件\n- 组件内部不维护 `state`，只根据外部组件传入的 `props` 进行渲染的组件，当 `props` 改变时，组件重新渲染。\n\n#### 2.使用场景\n\n- 组件不需要管理 state ，纯展示\n\n#### 3.总结\n\n组件内部状态且与外部无关的组件，可以考虑用状态组件，这样状态树就不会过于复杂，易于理解和管理。\n\n当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。比如自定义的 `<Button />`、`<Input />` 等组件。\n\n### 三、无状态组件优缺点\n\n**优点**\n\n- 简化代码、专注于 `render`\n- 组件不需要被实例化，无生命周期，提升性能\n- 输出（渲染）只取决于输入（属性），无副作用\n- 视图和数据的解耦分离\n\n**缺点**\n\n- 无法使用 `ref`\n- 无生命周期方法\n- 无法控制组件的重渲染，因为无法使用 `shouldComponentUpdate` 方法，当组件接受到新的属性时则会重渲染\n\n",
        "answer": "",
        "biz_type": 1,
        "qid": 202,
        "subject": "",
        "title": "说一下 React 有状态组件与无状态组件区别，以及为什么要用，它的优缺点"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 6,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/reactjinjie.gif",
        "style_tpl": 0,
        "text": "React不熟练怎么办",
        "title": "【专题课：React高级玩家必会指南】",
        "url": "https://mp.weixin.qq.com/s/NrgDKsi8H5SqEK9dVSPFsA"
      },
      "corp_tag": ["高德"],
      "is_favorite": false,
      "qid": 196,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 一、React Hook\n\n#### 1.1什么是React Hook\n\n**Hook** 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。\n\n从官网的这句话中，我们可以明确的知道，`Hook` 增加了函数式组件中`state`的使用，在之前函数式组件是无法拥有自己的状态，只能通过`props`以及`context`来渲染自己的`UI`，而在业务逻辑中，有些场景必须要使用到`state`，那么我们就只能将函数式组件定义为`class`组件。而现在通过`Hook`，我们可以轻松的在函数式组件中维护我们的状态，不需要更改为`class`组件。\n\nReact16.8加入hooks，让React函数式组件更加灵活\n\nhooks之前，React存在很多问题\n\n1. 在组件间复用状态逻辑很难\n2. 复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。\n3. class组件的this指向问题\n4. 难以记忆的生命周期\n\nhooks很好的解决了上述问题，hooks提供了很多方法\n\n1. useState 返回有状态值，以及更新这个状态值的函数\n2. useEffect 接受包含命令式，可能有副作用代码的函数。\n3. useContext 接受上下文对象（从React.createContext返回的值）并返回当前上下文值，\n4. useReducer useState的替代方案。接受类型为(state，action) => newState的reducer，并返回与dispatch方法配对的当前状态。 \n5. useCallback  返回一个回忆的memoized版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性\n6. useMemo 纯的一个记忆函数\n7. useRef 返回一个可变的ref对象，其.current属性被初始化为传递的参数\n8. useImperativeMethods 自定义使用ref时公开给父组件的实例值\n9. useMutationEffect 更新兄弟组件之前，它在React执行其DOM改变的同一阶段同步触发\n10. useLayoutEffect DOM改变后同步触发。使用它来从DOM读取布局并同步重新渲染\n\n\n#### 1.2.React Hook 要解决什么问题\n\n`React Hooks`要解决的问题是状态共享，这里的状态共享是指只共享状态逻辑复用，并不是指数据之间的共享。我们知道在`React Hooks`之前，解决状态逻辑复用问题，我们通常使用`higher-order components`和`render-props`。\n\n既然已经有了这两种解决方案，为什么`React`开发者还要引入`React Hook`？对于`higher-order components`和`render-props`，`React Hook`的优势在哪？\n\n> PS：Hook最大的优势其实还是对于状态逻辑的复用便捷，还有代码的简洁，以及帮助函数组件增强功能，\n\n我们先来看一下`React`官方给出的`React Hook`的`demo`\n\n```js\nimport { useState } from 'React';\n\nfunction Example() {\n  // Declare a new state variable, which we'll call \"count\"\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n\n```\n\n我们再来看看不用`React Hook`的话，如何实现\n\n```javascript\nclass Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Click me\n        </button>\n      </div>\n    );\n  }\n}\n```\n\n可以看到，在`React Hook`中，`class Example`组件变成了函数式组件，但是这个函数式组件却拥有的自己的状态，同时还可以更新自身的状态。这一切都得益于`useState`这个`Hook`，`useState` 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 `class` 组件的 `this.setState`，但是它不会把新的 `state` 和旧的 `state` 进行合并\n\n\n\n#### 1.3实现原理\n\nHooks 的基本类型：\n\n```js\ntype Hooks = {\n\tmemoizedState: any, // 指向当前渲染节点 Fiber\n  baseState: any, // 初始化 initialState， 已经每次 dispatch 之后 newState\n  baseUpdate: Update<any> | null,// 当前需要更新的 Update ，每次更新完之后，会赋值上一个 update，方便 react 在渲染错误的边缘，数据回溯\n  queue: UpdateQueue<any> | null,// UpdateQueue 通过\n  next: Hook | null, // link 到下一个 hooks，通过 next 串联每一 hooks\n}\n \ntype Effect = {\n  tag: HookEffectTag, // effectTag 标记当前 hook 作用在 life-cycles 的哪一个阶段\n  create: () => mixed, // 初始化 callback\n  destroy: (() => mixed) | null, // 卸载 callback\n  deps: Array<mixed> | null,\n  next: Effect, // 同上 \n};\n```\nReact Hooks 全局维护了一个 workInProgressHook  变量，每一次调取 Hooks API 都会首先调取 createWorkInProgressHooks  函数。\n```js\nfunction createWorkInProgressHook() {\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    if (firstWorkInProgressHook === null) {\n      currentHook = firstCurrentHook;\n      if (currentHook === null) {\n        // This is a newly mounted hook\n        workInProgressHook = createHook();\n      } else {\n        // Clone the current hook.\n        workInProgressHook = cloneHook(currentHook);\n      }\n      firstWorkInProgressHook = workInProgressHook;\n    } else {\n      // There's already a work-in-progress. Reuse it.\n      currentHook = firstCurrentHook;\n      workInProgressHook = firstWorkInProgressHook;\n    }\n  } else {\n    if (workInProgressHook.next === null) {\n      let hook;\n      if (currentHook === null) {\n        // This is a newly mounted hook\n        hook = createHook();\n      } else {\n        currentHook = currentHook.next;\n        if (currentHook === null) {\n          // This is a newly mounted hook\n          hook = createHook();\n        } else {\n          // Clone the current hook.\n          hook = cloneHook(currentHook);\n        }\n      }\n      // Append to the end of the list\n      workInProgressHook = workInProgressHook.next = hook;\n    } else {\n      // There's already a work-in-progress. Reuse it.\n      workInProgressHook = workInProgressHook.next;\n      currentHook = currentHook !== null ? currentHook.next : null;\n    }\n  }\n  return workInProgressHook;\n}\n```\n\n假设我们需要执行以下 hooks 代码：\n\n```js\nfunction FunctionComponet() {\n\t\n  const [ state0, setState0 ] = useState(0);\n  const [ state1, setState1 ] = useState(1);\n  useEffect(() => {\n  \tdocument.addEventListener('mousemove', handlerMouseMove, false);\n    ...\n    ...\n    ...\n    return () => {\n      ...\n      ...\n      ...\n    \tdocument.removeEventListener('mousemove', handlerMouseMove, false);\n    }\n  })\n  \n  const [ satte3, setState3 ] = useState(3);\n  return [state0, state1, state3];\n}\n```\n\n当我们了解 React Hooks 的简单原理，得到 Hooks 的串联不是一个数组，但是是一个链式的数据结构，从根节点 workInProgressHook 向下通过 next 进行串联。这也就是为什么 Hooks 不能嵌套使用，不能在条件判断中使用，不能在循环中使用。否则会破坏链式结构。\n\n### 二、和生命周期的区别\n\n函数组件 的本质是函数，没有 state 的概念的，因此不存在生命周期一说，仅仅是一个 render 函数而已。\n\n但是引入 Hooks 之后就变得不同了，它能让组件在不使用 class 的情况下拥有 state，所以就有了生命周期的概念，所谓的生命周期其实就是 useState、 useEffect() 和 useLayoutEffect() 。\n\n即：Hooks 组件（使用了Hooks的函数组件）有生命周期，而函数组件（未使用Hooks的函数组件）是没有生命周期的。\n\n下面，是具体的 class 与 Hooks 的生命周期对应关系：\n\n\n![hook & lifcycle](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-196-hook.png)\n\n",
        "answer": "",
        "biz_type": 1,
        "qid": 196,
        "subject": "",
        "title": "说一下对 React Hook 的理解，它的实现原理，和生命周期有哪些区别？"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["高德", "有赞", "酷家乐"],
      "is_favorite": false,
      "qid": 195,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "\n### 区别\n\nComponent是React App的基本构建的单位，也是React中的基本代码复用单位。PureComponent与Component在除了其shouldComponentUpdate方法的实现之外几乎完全相同。PureComponent已经替我们实现了shouldComponentUpdate方法。\n\n对于PureComponent而言，当其props或者state改变之时，新旧props与state将进行浅对比（shallow comparison）。另一方面，Component默认的情况下其shouldComponentUpdate方法并不进行新旧props与state的对比。\n\n对于基本类型(primitives），例如数字或者布尔值，来说，浅拷贝将会检查其值是否相同，例如1与1相等，true与true相等。对于引用类型的变量，例如复杂的javascript对象或者数组，来说，浅拷贝将仅仅检查它们的引用值是否相等。这意味着，对于引用类型的变量来说，如果我们只是更新了其中的一个元素，例如更新了数组中某一位置的值，那么更新前后的数组仍是相等的。\n\n因此意味着相比于Component，PureCompoent的性能表现将会更好。但使用PureCompoent要求满足如下条件：\n\n- props和state都必须是不可变对象（immutable object）。\n- props和state不能有层级嵌套的结构，（否则对子层级的改变无法反映在浅拷贝中）。\n- 如果数据改变无法反应在浅拷贝上，则应该调用forceUpdate来更新Component。\n- 一个PureComponent的子Component也应当是PureComponent。\n\n### 简洁回答\n\n- React.Component需要自己实现shouldComponentUpdate()。\n- React.PureComponent 通过props和state的浅对比来实现 shouldComponentUpate()。\n- 如果定义了 shouldComponentUpdate()，无论组件是否是 PureComponent，它都会执行shouldComponentUpdate结果来判断是否 update。如果组件未实现 shouldComponentUpdate() ，则会判断该组件是否是 PureComponent，如果是的话，会对新旧 props、state 进行比较，一旦新旧不一致，会触发 update。\n- React.PureComponent优点：是不需要开发者自己实现shouldComponentUpdate，就可以进行简单的判断来提升性能。\n- React.PureComponent缺点：可能会因深层的数据不一致而产生错误的否定判断，从而shouldComponentUpdate结果返回false，界面得不到更新。",
        "answer": "",
        "biz_type": 1,
        "qid": 195,
        "subject": "",
        "title": "说一下 React.Component 和 Ract.PureComponent 的区别"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 4,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhiyeguihua.gif",
        "style_tpl": 0,
        "text": "前端路上没人带，老走弯路？",
        "title": "【专题课：十年前端老兵亲述：我和前端这十年】",
        "url": "https://mp.weixin.qq.com/s/J4qABCwfd6HyafOLLSgbvQ"
      },
      "corp_tag": ["脉脉"],
      "is_favorite": false,
      "qid": 226,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "\n### 优化方式\n\nReact 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以我们的业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。\n\n这里提下优化的点\n\n#### 1.shouldComponentUpdate 和 PureComponent\n\n在 React 类组件中，可以利用 shouldComponentUpdate 或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。\n\n**shouldComponentUpdate:** （nextProps,nextState）在内部可以判断组件外部接受的最新属性与之前的属性是否一致，从而约束render刷新的时机。 只要结果返回true，render就会立马执行渲染更新，返回false就代表render不会执行。\n\n**PureComponent:** 内部机制是通过浅比较去实现的。PureComponent代表纯组件，纯组件内部是不能再去复写shouldComponentUpdate这个钩子函数了,内部进行浅比较(进行值比较或者内部地址的比较)，进行性能的优化。如果是值比较的话，外部传入的属性与内部的属性不一样的话，才会进行render更新操作。如果是引用地址比较的话，例如数组，之前的属性数组的地址与更改后的新的数组的地址一致，那么就不会进行render的更新操作\n\n#### 2.利用高阶组件\n\n在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能\n\n#### 3.使用 React.memo\n\nReact.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo 只能用于函数组件 。\n\n#### 4.合理拆分组件\n\n微服务的核心思想是：以更轻、更小的粒度来纵向拆分应用，各个小应用能够独立选择技术、发展、部署。我们在开发组件的过程中也能用到类似的思想。试想当一个整个页面只有一个组件时，无论哪处改动都会触发整个页面的重新渲染。在对组件进行拆分之后，render 的粒度更加精细，性能也能得到一定的提升。",
        "answer": "",
        "biz_type": 1,
        "qid": 226,
        "subject": "",
        "title": "React 如何避免 render 的触发"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["网易", "脉脉", "快手"],
      "is_favorite": false,
      "qid": 159,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "\n### 一、相似之处\n\n- 都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库\n- 都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。\n- 都使用了'Virtual DOM'（虚拟DOM）提高重绘性能\n- 都有’props’的概念，允许组件间的数据传递\n- 都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性\n\n### 二、不同之处\n\n#### 1.数据流\n\nVue默认支持数据双向绑定，而React一直提倡单向数据流\n\n#### 2.虚拟DOM\n\nVue2.x 开始引入“Virtual DOM”，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点\n\n- Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。\n\n- 对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。\n\n#### 3.组件化\n\nReact与Vue最大的不同是模板的编写。\n\nVue鼓励你去写近似常规HTML的模板。写起来很接近标准HTML元素，只是多了一些属性。React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。\n\n具体来讲：\n\nReact中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以我们import 一个组件完了之后，还需要在 components 中再声明下。\n\n#### 4.监听数据变化的实现原理不同\n\n- Vue 通过 `getter/setter` 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能\n- React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的VDOM的重新渲染。这是因为Vue 使用的是可变数据，而React更强调数据的不可变。\n\n#### 5.高阶组件\n\nreact可以通过高阶组件（Higher Order Components--HOC）来扩展，而vue需要通过mixins来扩展\n\n原因高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不采用HoC来实现。\n\n#### 6.构建工具\n\n两者都有自己的构建工具\n\n- React ==> Create React APP\n- Vue ==> vue-cli\n\n#### 7.跨平台\n\n- React ==> React Native\n- Vue ==> Weex",
        "answer": "",
        "biz_type": 1,
        "qid": 159,
        "subject": "",
        "title": "说一下对 React 和 Vue 的理解，它们的异同"
      },
      "tech_tag": ["React", "Vue"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 2,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhuantaiguanli.gif",
        "style_tpl": 0,
        "text": "缺少实战经验？一键解决！",
        "title": "【专题课：你不知道的硬核数据状态管理】",
        "url": "https://mp.weixin.qq.com/s/k6MblcpoJNaTpVVp5Z0eZA"
      },
      "corp_tag": ["脉脉", "菜鸟网络", "蘑菇街"],
      "is_favorite": false,
      "qid": 228,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "\n### 一、什么是虚拟Dom\n\n从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而**有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能**。\n\n虚拟dom是对DOM的抽象，这个对象是更加轻量级的对DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM,如果想实现SSR,那么一个方式就是借助虚拟dom, 因为虚拟dom本身是js对象。\n\n在代码渲染到页面之前，vue或者react会把代码转换成一个对象（虚拟DOM）。以对象的形式来描述真实dom结构，最终渲染到页面。在每次数据发生变化前，虚拟dom都会缓存一份，变化之时，现在的虚拟dom会与缓存的虚拟dom进行比较。\n\n在vue或者react内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。\n\n另外现代前端框架的一个基本要求就是无须手动操作DOM,一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。\n\n### 二、为什么要用 Virtual DOM\n\n#### 1.保证性能下限，在不进行手动优化的情况下，提供过得去的性能\n\n看一下页面渲染的一个流程：\n\n- 解析HTNL ☞ 生成DOM? ☞ 生成 CSSOM ☞ Layout ☞ Paint ☞ Compiler\n\n下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗：\n\n- 真实DOM： 生成HTML字符串 + 重建所有的DOM元素\n- Virtual DOM： 生成vNode + DOMDiff + 必要的dom更新\n\nVirtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道： **框架给你的保证是，你不需要手动优化的情况下，我依然可以给你提供过得去的性能。**\n\n#### 2.跨平台\n\nVirtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。\n\n### 三、Virtual DOM真的比真实DOM性能好吗\n\n1. 首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。\n2. 正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。",
        "answer": "",
        "biz_type": 1,
        "qid": 228,
        "subject": "",
        "title": "说一下对 vnode 的理解，vnode 的引入与直接操作原生 dom 相比，哪一个相率更高，为什么"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 2,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhuantaiguanli.gif",
        "style_tpl": 0,
        "text": "缺少实战经验？一键解决！",
        "title": "【专题课：你不知道的硬核数据状态管理】",
        "url": "https://mp.weixin.qq.com/s/k6MblcpoJNaTpVVp5Z0eZA"
      },
      "corp_tag": ["百分点"],
      "is_favorite": false,
      "qid": 270,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "\n### 一、React 16.x\n\n#### 1.1 React 16.x的三大新特性 \n\n**Time Slicing, Suspense，hooks**\n\n1. Time Slicing（解决CPU速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得react能在性能极其差的机器跑时，仍然保持有良好的性能\n2. Suspense （解决网络IO问题）和lazy配合，实现异步加载组件。 能暂停当前组件的渲染, 当完成某件事以后再继续渲染，解决从react出生到现在都存在的「异步副作用」的问题，而且解决得非常的优雅，使用的是「异步但是同步的写法」，我个人认为，这是最好的解决异步问题的方式\n3. 此外，还提供了一个内置函数 componentDidCatch，当有错误发生时, 我们可以友好地展示 fallback 组件；可以捕捉到它的子元素（包括嵌套子元素）抛出的异常；可以复用错误组件。\n\n### 二、详细看一下\n\n#### 2.1 React v16.0\n\n**1）render可以返回字符串，数组，数字**\n\nReact 15: 只可以返回单一组件，也就是说即使你返回的是一个string，也需要用div包住。\n\n```js\nfunction MyComponent() {\n  return (\n    <div>\n       hello world\n    <div>\n  );\n}\n```\n\nReact 16: 支持返回这五类：React elements, 数组和Fragments，Portal，String/numbers，boolean/null\n\n```js\nclass Example extends React.Component {\n  render() {\n    return [\n      <div key=\"1\">first element</div>,\n      <div key=\"2\">second element</div>,\n    ];\n  }\n}\n```\n\n**2）Error boundary（错误边界）**\n\nReact 15：渲染过程中有出错，直接crash整个页面，并且错误信息不明确，可读性差\n\nReact 16：用于捕获子组件树的JS异常（即错误边界只可以捕获组件在树中比他低的组件错误。），记录错误并展示一个回退的UI。\n\n捕获范围：\n\n- 渲染期间\n- 生命周期内\n- 整个组件树构造函数内\n\n**3）react portal**\n\nPortal可以帮助我们在JSX中跟普通组件一样直接使用dialog, 但是又可以让dialog内容层级不在父组件内，而是显示在独立于原来app在外的同层级组件。\n\n之前的写法\n\n```js\n<div class=\"app\">\n   <div> ... </div>\n   { needDialog ? <Dialog /> : null }\n</div>\n```\n\n这样写的问题就是:\n\n- 最终渲染产生的html存在于JSX产生的HTML在一起，这时候dialog 如果需要position：absolute 控制位置的话，需要保证dialog 往上没有position：relative 的干扰。\n- 层级关系不清晰，dialog实际是独立在app之外的。\n\nportal的出现就很好的解决了这个问题\n\n**4）自定义DOM属性**\n\nReact 15：忽略未标准化的html 和 svg属性\n\nReact 16：去掉了这个限制\n\n为什么要做这个改动呢？两个原因：\n\n- 不能用自定义属性，对于非标准（proposal阶段）新属性还有其他框架（Angular）很不友好\n- React 15之所以可以过滤掉非标准的属性，是因为他们维护了一个白名单的文件（放在bundle size 里）。而随着时间的增加，标准化的属性越来越多，意味着要一直维护这个文件，同时这个文件也会越来越大，增加bundle的体积。\n\n**5）优化SSR**\n\n具体优化了下面五个方面：\n\n- 生成更简洁的HTML\n- 宽松的客户端一致性校验\n    - react 15：会将SSR的结果与客户端生成的做一个个字节的对比校验 ，一点不匹配发出waring同时就替换整个SSR生成的树。\n    - react 16：对比校验会更宽松一些，比如，react 16允许属性顺序不一致，而且遇到不匹配的标签，还会做子树的修改，不是整个替换。\n- 无需提前编译  \n    - react 15：如果你直接使用SSR，会有很多需要检查procee.env的地方，但是读取在node中读取process.env是很消耗时间的。所以在react 15的时候，需要提前编译，这样就可以移除 process.env的引用。\n    - react 16：只有一次检查process.env的地方，所以就不需要提前编译了，可以开箱即用。\n- react 16服务端渲染速度更快\n    - react 15下，server client都需要生成vDOM，但是其实在服务端， 当我们使用renderToString的时候，生成的vDom就会被立即抛弃掉， 所以在server端生成vDom是没有意义的。\n- 支持流式渲染\n\n**6）减小了32%bundle的体积**\n\nReact 库大小从 20.7kb（压缩后 6.9kb）降低到 5.3kb（压缩后 2.2kb）\n\nReactDOM 库大小从 141kb（压缩后 42.9kb）降低到 103.7kb（压缩后 32.6kb）\n\nReact + ReactDOM 库大小从 161.7kb（压缩后 49.8kb）降低到 109kb（压缩后 43.8kb）\n\n#### 2.2 React V16.2\n\n主要特性：Fragement\n\nReact 15：render函数只能接受一个组件，所以一定要外层包一层 `<div>`。\n\nReact16：可以通过Fragement直接返回多个组件。\n\n#### 2.3 React V16.3\n\n**1）新的生命周期函数**\n\n由于异步渲染的改动，componentWillMount, componentWillReceiveProps,componentWillUpdate 三个函数被抛弃。\n\n由于这是一个很大的改变会影响很多现有的组件，所以需要慢慢的去改。 目前react 16 只是会报waring，在react 17你就只能在前面加\"UNSAFE_\" 的前缀 来使用。不能不说react团队真是太贴心了，他们还写了一个脚本自动帮你加上 这些前缀。\n\n同时新加了两个生命周期函数来替代他们，分别是getDerivedStateFromProps，getSnapshotBeforeUpate\n\n**2）新的 contextAPI**\n\ncontext 就是可以使用全局的变量，不需要一层层pass props下去,但是需要谨慎使用，因为这会让你的组件复用性变差。 一般来说，如果你只是想避免需要传很多次props的话，可以直接使用component composition（就是通过props自己传给指定的）会更好。 \n\n**3）crateRef API**\n\nreact15 的时候提供了两种refs的方法： string 跟 callback string,由于用string的方式会导致一些潜在的问题，所以之前推荐使用callback。但是用string的方法明显方便一点。\n\n所以react 团队get到了大家的需求，又出了一个新的api 可以用string的方式而且还没有缺点\n\n**4）forwardRef API**\n\n使用场景： 父组件需要将自己的引用传给子组件\n\n**5）strictMode component**\n\n严格模式用来帮助开发者发现潜在问题的工具。就像Fragment 一样，它不会render任何的DOM 元素。注意：只有在development模式下才能用。\n\n#### 2.4 React V16.4\n\n- 新增指针事件\n- fix生命周期函数\n\n#### 2.5 React V16.5\n\n- 提供新的调试工具\n\n这个版本提供了对新的Profiler DevTools插件的支持。这个插件就厉害了，可以通过收集每个组件的渲染耗时，来帮助我们找到ReactApp的渲染瓶颈，并且整个界面更加清爽清晰，简直是开发者的福利。\n\n#### 2.6 React V16.6\n\n- memo\n- lazy\n- suspense\n- 简化 contextType\n- 增加 getDerivedStateFromError\n\n**memo**\n\nReact 15：如果你想阻止组件的重复渲染，在class component里可以使用PureComponent, shouldComponentUpdate来帮助你。但是如果你是function component，对不起，没有这个功能， 只能每次都重新渲染。\n\nReact 16：为了全面拥抱function component,React团队写了memo来帮助function component实现这个阻止重复渲染的功能。\n\n#### 2.7 React16.8加入hooks，让React函数式组件更加灵活\n\n**hooks之前，React存在很多问题**\n\n1. 在组件间复用状态逻辑很难\n2. 复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。\n3. class组件的this指向问题\n4. 难以记忆的生命周期\n\n**hooks很好的解决了上述问题，hooks提供了很多方法**\n\n1. useState 返回有状态值，以及更新这个状态值的函数\n2. useEffect 接受包含命令式，可能有副作用代码的函数。\n3. useContext 接受上下文对象（从React.createContext返回的值）并返回当前上下文值，\n4. useReducer useState的替代方案。接受类型为(state，action) => newState的reducer，并返回与dispatch方法配对的当前状态。 \n5. useCallback  返回一个回忆的memoized版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性\n6. useMemo 纯的一个记忆函数\n7. useRef 返回一个可变的ref对象，其.current属性被初始化为传递的参数\n8. useImperativeMethods 自定义使用ref时公开给父组件的实例值\n9. useMutationEffect 更新兄弟组件之前，它在React执行其DOM改变的同一阶段同步触发\n10. useLayoutEffect DOM改变后同步触发。使用它来从DOM读取布局并同步重新渲染\n\n",
        "answer": "",
        "biz_type": 1,
        "qid": 270,
        "subject": "",
        "title": "React15/16.x 的区别"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["阿里", "脉脉"],
      "is_favorite": false,
      "qid": 224,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "\n### React-redux\n\n当一个react项目组件层级越来越深，页面越来越多的时候，数据在各个组件层级和页面之间传递的需求就会比较多，很多变量也需要做成可全局管理的。在这个时候，redux和react-redux的使用就很有必要了。它们能帮助我们很方便的进行项目全局性的数据管理。\n\n#### 1.1 几个重要的概念\n\n**1.1.1 action**\n\nAction 是把数据从应用（这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 `store.dispatch()` 将 action 传到 store。\n\n**1.1.2 reducer**\n\nReducers 指定了应用状态的变化如何响应 actions并发送到 store 的，记住 actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state。\n\n**1.1.3 store**\n\nstore就是把action和reducer联系到一起的对象，store本质上是一个状态树，保存了所有对象的状态。任何UI组件都可以直接从store访问特定对象的状态。\n\n在 Redux 中，所有的数据（比如state）被保存在一个store容器中 ，在一个应用程序中只能有一个store对象。当一个store接收到一个action，它将把这个action代理给相关的reducer。reducer是一个纯函数，它可以查看之前的状态，执行一个action并且返回一个新的状态。\n\n**1.1.4 Provider**\n\nProvider 其实就只是一个外层容器，它的作用就是通过配合 connect 来达到跨层级传递数据。使用时只需将Provider定义为整个项目最外层的组件，并设置好store。那么整个项目都可以直接获取这个store。它的原理其实是通过React中的[Context]()来实现的。它大致的核心代码如下：\n\n```js\nimport React, {Component} from 'react'\nimport {PropTypes} from 'prop-types'\n\nexport default class Provider extends Component {\n    getChildContext() {\n        return {store: this.props.store}\n    }\n\n    constructor() {\n        super()\n\n        this.state = {}\n    }\n\n    render() {\n        return this.props.children\n    }\n}\n\nProvider.childContextTypes = {\n    store: PropTypes.object\n}\n```\n\n**1.1.5 connect**\n\nconnect 的作用是连接React组件与 Redux store，它包在我们的容器组件的外一层，它接收上面 Provider 提供的 store 里面的 state 和 dispatch，传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件。\n\n它共有四个参数mapStateToProps, mapDispatchToProps, mergeProps以及options。\n\n- mapStateToProps 的作用是将store里的state（数据源）绑定到指定组件的props中\n- mapDispatchToProps 的作用是将store里的action（操作数据的方法）绑定到指定组件的props中\n\nconnect 是怎么将React组件与 Redux store连接起来的呢？其主要逻辑可以总结成以下代码：\n\n```js\nimport {Component} from \"react\";\nimport React from \"react\";\nimport {PropTypes} from 'prop-types'\n\nconst connect = (mapStateToProps, mapDispatchToProps) => (WrappedComponent => {\n    class Connect extends Component {\n        constructor() {\n            super()\n            this.state = {}\n        }\n        componentWillMount() {\n            this.unSubscribe = this.context.store.subscribe(() => {\n                this.setState(mapStateToProps(this.context.store.getState()))\n            })\n        }\n        componentWillUnmount() {\n            this.unSubscribe()\n        }\n        render() {\n            return <WrappedComponent  {...this.state}\n                {...mapDispatchToProps(this.context.store.dispatch)}/>\n        }\n    }\n    Connect.contextTypes = {\n        store: PropTypes.object\n    }\n    return Connect\n})\n\nexport default connect\n```\n\n#### 1.2  一些理解\n\n- React-Redux是连接React和Redux的库，同时使用了React和Redux的API。\n- React-Redux主要是使用了React的context api来传递Redux的store。\n- Provider的作用是接收Redux store并将它放到context上传递下去。\n- connect的作用是从Redux store中选取需要的属性传递给包裹的组件。\n- connect会自己判断是否需要更新，判断的依据是需要的state是否已经变化了。\n- connect在判断是否变化的时候使用的是浅比较，也就是只比较一层，所以在mapStateToProps和mapDispatchToProps中不要反回多层嵌套的对象。\n- 为了解决父组件和子组件各自独立依赖Redux，破坏了React的父级->子级的更新流程，React-Redux使用Subscription类自己管理了一套通知流程。\n- 只有连接到Redux最顶级的组件才会直接注册到Redux store，其他子组件都会注册到最近父组件的subscription实例上。\n- 通知的时候从根组件开始依次通知自己的子组件，子组件接收到通知的时候，先更新自己再通知自己的子组件。\n\n#### 1.3 主要解决的问题\n\n单纯的Redux只是一个状态机，是没有UI呈现的，react-redux作用是将Redux的状态机和React的UI呈现绑定在一起，当你dispatch action改变state的时候，会自动更新页面。",
        "answer": "",
        "biz_type": 1,
        "qid": 224,
        "subject": "",
        "title": "说一下对 React-redux 的理解以及它的原理，主要解决什么问题"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["脉脉", "酷家乐"],
      "is_favorite": false,
      "qid": 223,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "\n\n### React context\n\n在React中，数据传递一般使用props传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单项数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，props就需要层层传递显然，这样做太繁琐了！\n\nContext 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。\n\n可以把context当做是特定一个组件树内共享的store，用来做数据传递。简单说就是，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。\n\n有了解JS作用域链概念的开发者应该都知道，JS的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时JS代码块执行期间所能访问的活动对象，包括变量和函数，JS程序通过作用域链访问到代码块内部或者外部的变量和函数。\n\n假如以JS的作用域链作为类比，React组件提供的Context对象其实就好比一个提供给子组件访问的作用域，而Context对象的属性可以看成作用域上的活动对象。由于组件的Context由其父节点链上所有组件通过getChildContext()返回的Context对象组合而成，所以，组件通过Context是可以访问到其父组件链上所有节点组件提供的Context的属性。",
        "answer": "",
        "biz_type": 1,
        "qid": 223,
        "subject": "",
        "title": "说一下对 React context 的理解"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["伴鱼"],
      "is_favorite": false,
      "qid": 91,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "**1）useState**\n\n` const [count, setCount] = useState(0)`\n\nuseState 运用了JavaScript 解构赋值的思想\n \n数组和对象解构赋值的区别是：\n\n- 数组的元素是按次序排列的，数组解构时变量的取值由数组元素的位置决定，变量名可以任意命名.\n- 对象的属性没有次序，解构时变量名必须与属性同名，才能取到正确的值。\n- 因此使用数组会更灵活，可以任意命名 state 和修改 state 的方法名。\n\n**2）为什么要使用数组而不是对象**\n\n因为useState内部原理是把state声明成一个数组，需要顺序一一对应\n\n```js\nfunction App(){\n    const [number, setNumber] = React.useState(0)\n    return (\n        <div className='App'>\n            <p>{number}</p >\n            <p>\n              <button onClick={() => setNumber(number + 1)}>+1</button>\n            </p >\n        </div>\n    )\n}\n```\n\n每次点击button number的值都会+1 组件都会重新render\n\n**3）通过自己实现一个React.useState来深入理解**\n\n**①代码实现**\n\n```js\nlet _state //全局_state用来存储state的值，避免重新渲染的时候被myUseState重置为初始值\nconst myUseState = initialValue => {\n    _state = _state === undefined ? initialValue : _state\n    const setState = (newValue) => {\n        _state = newValue\n        render()\n    }\n    return [_state, setState]\n}\n\nconst render = () => {\n    ReactDOM.render(<App1 />, document.getElementById('root'))\n}\n\nfunction App1(){\n    const [n, setN] = myUseState(0)\n    return (\n        <div className='App'>\n            <p>{n}</p >\n            <p>\n                <button onClick={() => setN(n + 1)}>+1</button>\n            </p >\n        </div>\n    )\n}\n```\n\n上面的方案用一个useState可行，如果一个组件用了两个useState，由于数据都放在_state里，所以会冲突。\n\n改进思路：把_state做成数组，比如_state = [0,0]\n\n**②改进方案**\n\n```js\nlet _state = [] //全局_state用来存储state的值，避免重新渲染的时候被myUseState重置为初始值\nlet index = 0\nconst myUseState = initialValue => {\n    const currentIndex = index\n    _state[currentIndex] = _state[currentIndex] === undefined ? initialValue : _state[currentIndex]\n    const setState = newValue => {\n        _state[currentIndex] = newValue\n        render()\n    }\n    index += 1\n    return [_state[currentIndex], setState]\n}\n\nconst render = () => {\n    index = 0\n    ReactDOM.render(<App1 />, document.getElementById('root'))\n}\n\nfunction App1(){\n    const [n, setN] = myUseState(0)\n    const [m, setM] = myUseState(0)\n    return (\n        <div className='App'>\n            <p>{n}</p >\n            <p>\n                <button onClick={() => setN(n + 1)}>+1</button>\n            </p >\n            <p>{m}</p >\n            <p>\n                <button onClick={() => setM(m + 1)}>+1</button>\n            </p >\n        </div>\n    )\n}\n```\n\n**③得出结论**\n\n`[state, setState] = useState(initialValue)`返回一个包含2个元素的数组:状态值和状态更新函数。\n\n内部原理是把state声明成一个数组，需要顺序一一对应。\n\n由于一个组件可以使用多个useState，为了避免冲突并确保state的准确性，useState 要使用数组而不是对象。",
        "answer": "",
        "biz_type": 1,
        "qid": 91,
        "subject": "",
        "title": "为什么 useState 要使用数组而不是对象"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 3,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/vue3.gif",
        "style_tpl": 0,
        "text": "Vue 3.0 来了，我们该做些什么？",
        "title": "【专题课：Vue从无到有的思想精髓】",
        "url": "https://mp.weixin.qq.com/s/goLDOUSsBXsPe_7C5PmpRA"
      },
      "corp_tag": ["快手"],
      "is_favorite": false,
      "qid": 72,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "**1）Redux 和 Vuex区别**\n\n- Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch,只需在对应的mutation函数里改变state值即可\n- Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可\n- Vuex数据流的顺序是:View调用store.commit提交对应的请求到Store中对应的mutation函数->store改变(vue检测到数据变化自动渲染)\n\n通俗点理解就是，vuex 弱化 dispatch, 通过commit进行store状态的一次更变;取消了action概念, 不必传入特定的action形式进行指定变更; 弱化reducer, 基于commit参数直接对数据进行转变, 使得框架更加简易;\n\n**2）共同思想**\n\n- 单一的数据源\n- 变化可以预测\n\n**本质上：** redux与vuex都是对mvvm思想的服务, 将数据从视图中抽离的一种方案;\n\n**形式上：** vuex借鉴了redux, 将store作为全局的数据中心, 进行mode管理;\n\n",
        "answer": "",
        "biz_type": 1,
        "qid": 72,
        "subject": "",
        "title": "Redux 和 Vuex 有什么区别，说下一它们的共同思想"
      },
      "tech_tag": ["React", "Vue"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 2,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhuantaiguanli.gif",
        "style_tpl": 0,
        "text": "缺少实战经验？一键解决！",
        "title": "【专题课：你不知道的硬核数据状态管理】",
        "url": "https://mp.weixin.qq.com/s/k6MblcpoJNaTpVVp5Z0eZA"
      },
      "corp_tag": [],
      "is_favorite": false,
      "qid": 52,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 答案\n\n这三者是目前react解决代码复用的主要方式。\n\n高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。\n\nrender props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。\n\n通常，render props 和高阶组件只渲染一个子节点。让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 renderItem 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，Hook 足够了，并且能够帮助减少嵌套。\n\n#### HOC\n\n> 官方解释：高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。\n\n简言之，HOC是一种组件的设计模式，HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。\n\n看一个例子：\n\n```js\n// hoc的定义\nfunction withSubscription(WrappedComponent, selectData) {\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        data: selectData(DataSource, props)\n      };\n    }\n    // 一些通用的逻辑处理\n    render() {\n      // ... 并使用新数据渲染被包装的组件!\n      return <WrappedComponent data={this.state.data} {...this.props} />;\n    }\n  };\n\n// 使用\nconst BlogPostWithSubscription = withSubscription(BlogPost,\n  (DataSource, props) => DataSource.getBlogPost(props.id));\n```\n\nhoc的优缺点：\n\n- 优点： 逻辑服用、不影响被包裹组件的内部逻辑\n- 缺点：hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖\n\n\n#### Render props\n\n> 官方解释：术语 “render prop” 是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术\n\n具有 render prop 的组件接受一个返回React 元素的函数，将render的渲染逻辑注入到组件内部。在这里，“render”的命名可以是任何其他有效的标识符。\n\n看一个例子：\n\n```js\n// DataProvider组件内部的渲染逻辑如下\nclass DataProvider extends React.Components {\n \tstate = {\n    name: 'Tom'\n  }\n\n\trender() {\n    return (\n    \t<div>\n      \t<p>共享数据组件自己内部的渲染逻辑</p>\n      \t{ this.props.render(this.state) }\n      </div>\n    );\n  }\n}\n\n// 调用方式\n<DataProvider render={data => (\n  <h1>Hello {data.name}</h1>\n)}/>\n\n```\n\n\n由此可以看到，render props的优缺点也很明显：\n\n- 优势：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者\n- 劣势：无法在 return 语句外访问数据、嵌套写法不够优雅\n\n\n\n#### Hooks\n\n> 官方：*Hook* 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。通过自定义hook，可以复用代码逻辑。\n\n看个例子：\n\n```js\n// 自定义一个获取订阅数据的hook\nfunction useSubscription() {\n  const data = DataSource.getComments();\n  return [data];\n}\n// \nfunction CommentList(props) {\n  const {data} = props;\n  const [subData] = useSubscription();\n\t...\n}\n// 使用\n<CommentList data='hello' />\n```\n\n以上可以看出，hook解决了hoc的prop覆盖的问题，同时使用的方式解决了render props的嵌套地狱的问题；\n\nhook的优点如下：\n\n- 使用直观\n- 解决hoc的prop 重名问题\n- 解决render props 因共享数据 而出现嵌套地狱的问题\n- 能在return之外使用数据的问题\n\n> 需要注意的是：hook只能在组件顶层使用，不可在分支语句中使用。\n\n#### 总结：\n\nHoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。\n",
        "answer": "",
        "biz_type": 1,
        "qid": 52,
        "subject": "",
        "title": "React 高阶组件 renderprops hooks 有什么区别，为什么要不断迭代"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 4,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhiyeguihua.gif",
        "style_tpl": 0,
        "text": "前端路上没人带，老走弯路？",
        "title": "【专题课：十年前端老兵亲述：我和前端这十年】",
        "url": "https://mp.weixin.qq.com/s/J4qABCwfd6HyafOLLSgbvQ"
      },
      "corp_tag": ["脉脉"],
      "is_favorite": false,
      "qid": 54,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 答案\n\nReact通过引入Virtual DOM的概念，极大地避免无效的Dom操作，已使我们的页面的构建效率提到了极大的提升。但是如何高效地通过对比新旧Virtual DOM来找出真正的Dom变化之处同样也决定着页面的性能，React用其特殊的diff算法解决这个问题。Virtual DOM+React diff的组合极大地保障了React的性能，使其在业界有着不错的性能口碑。diff算法并非React首创，React只是对diff算法做了一个优化，但却是因为这个优化，给React带来了极大的性能提升，\n\n\n####  react dom-diff策略\n\n![react-diff策略](http://img-static.yidengxuetang.com/wxapp/issue-img/react-diff.png)\n\n1. Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。\n2. 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。\n3. 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。\n\n基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化。\n\n**1）tree diff**\n\n基于策略1，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。\n\n由于 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对同一个父节点下的所有子节点进行比较。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。\n\n**2）component diff**\n\nReact 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。\n\n- 如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。\n- 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。\n- 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切- 的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。\n\n**3）element diff**\n\n当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。\n\n- INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。\n- MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 preChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。\n- REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。\n\n允许开发者对同一层级的同组子节点，添加唯一key进行区分\n",
        "answer": "",
        "biz_type": 1,
        "qid": 54,
        "subject": "",
        "title": "说一下 React diff 算法"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 4,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhiyeguihua.gif",
        "style_tpl": 0,
        "text": "前端路上没人带，老走弯路？",
        "title": "【专题课：十年前端老兵亲述：我和前端这十年】",
        "url": "https://mp.weixin.qq.com/s/J4qABCwfd6HyafOLLSgbvQ"
      },
      "corp_tag": ["网易"],
      "is_favorite": false,
      "qid": 53,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 答案\n\nreact的类组建通过state管理内部状态，而唯一改变状态更新的视图只能通过setState和forceUpdate。\n\nsetState最终也会走forceUpdate。那么我们首先要知道，每个类组建都有一个updater对象用于管理state的变化，\n\n当我们调用setState传入partialState时，会将partialState存入updater中的pendingState中，\n\n此时我们updater又会调用emitUpdate来决定当前是否立即更新，判断条件简单来说是否有nextProps，或者updateQueue的isPending是否开启。\n\nupdateQueue用于批量管理updater。\n\n如果updatequeue的isPendiing为true，那么就将当前update直接加入updateQueue的队列中。\n\n开启isPending的方式可以是自定义方法和生命周期函数等。\n\n当这些方法执行完毕更新update，调用update的componentUpdate，判断组件的shouldComponentUpdate决定是否调用forceUpdate进行更新。\n",
        "answer": "",
        "biz_type": 1,
        "qid": 53,
        "subject": "",
        "title": "说一下 React setState 原理"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 2,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhuantaiguanli.gif",
        "style_tpl": 0,
        "text": "缺少实战经验？一键解决！",
        "title": "【专题课：你不知道的硬核数据状态管理】",
        "url": "https://mp.weixin.qq.com/s/k6MblcpoJNaTpVVp5Z0eZA"
      },
      "corp_tag": [
        "完美世界",
        "高德",
        "脉脉",
        "有赞",
        "挖财",
        "沪江",
        "携程",
        "喜马拉雅",
        "酷家乐"
      ],
      "is_favorite": false,
      "qid": 55,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 答案\n\nReact生命周期钩子函数都是针对类组件的，即所有的钩子函数都写在class定义的类组件中。\n\n在React 15版本生命周期只有三个阶段，而在React 16版本新增了一个阶段： 错误处理阶段。\n\nReact16版本生命周期共分为四个阶段，有12个钩子函数，四个阶段分别为，初始化、运行中、销毁、错误处理(16.3之后)\n\n组件从被创建到被销毁的过程称为组件的生命周期。通常可以分为三个阶段：**挂载阶段、更新阶段、卸载阶段**\n\n![react-lifecycles](http://img-static.yidengxuetang.com/wxapp/issue-img/reacglyfecle.png)\n\n#### 一、挂载阶段\n\n**constructor**\n\n在这个方法中需要接收父组件传递过来的props属性对象，必须在这个方法中调用super(props)才能保证props被传入组件中。\n\n该方法通常用于初始化组件的state以及绑定事件处理方法\n\n```js\n// Footer.js\n  constructor(props) {\n    super(props);\n    // 初始化state状态\n    this.state = {\n      count: 0,\n      isShow: true\n    };\n    // 将事件处理函数绑定到类实例上\n    // this.handleAdd = this.handleAdd.bind(this);\n  }\n```\n\n\n\n**componentWillMount**\n\n组件即将挂载，在render之前调用\n\n这个方法在组件被挂载到DOM前调用，且只会被调用一次。这个方法在实际项目中很少会用到，因为可以在该方法中执行的工作都可以提前到constructor中。在这个方法中调用this.setState不会引起组件的重新渲染。\n\n注意的是：在React16.3版本之后不应该使用,因为官网中已经标记为过时，虽然仍然可以使用，但是不推荐再使用。由于该函数在Render函数之前调用,因此使用同步的setState方法不会触发额外的render处理\n\n```js\n// Footer.js\n  componentWillMount(){\n    console.log('组件挂载到dom之前执行，我只会调用一次，调用setState不会触发组件的重新渲染');\n  }\n\n// 会有警告，提示将不被再使用，现在已经重命名，在未来版本将不再被使用\n\n// 改为  UNSAFE_componentWillMount  警告会消失\n```\n\n在这个生命周期，数据可以获取到，但是真实DOM没有获取到，它相当于是Vue生命周期中 created + beforeMount。\n\n因为这个钩子可能会产生副作用或是订阅，所以几乎不会使用这个钩子函数\n\n还有它可以在服务端被调用，就是这个方法可以用于在服务器上渲染,这个方法因为是在渲染之前被调用，也是惟一一个可以直接同步修改state的地方。\n\n**render**\n\n这是定义组件时唯一必要的方法（组件的其他生命周期方法都可以省略）。在这个方法中，根据组件的props和state返回一个React元素，用于描述组件的UI，通常React元素使用JSX语法定义。需要注意的是，render并不负责组件的实际渲染工作，它只是返回一个UI的描述，真正的渲染出页面DOM的工作由React自身负责。\n\n要知道的是：render()方法必须是一个纯函数，他不应该改变state，也不能直接和浏览器进行交互，应该将事件放在其他生命周期函数中。在这个方法中不能执行任何有副作用的操作，所以**不能在render中调用this.setState，这会改变组件的状态。\n\n如果shouldComponentUpdate()返回false，render()不会被调用。\n\n主要两个作用：\n\n1. 计算 this.props / this.state 返回对应的结果\n2. 通过React.createElement将 jsx 转化为 VDOM对象模型 【重要】\n\n**componentDidMount**\n\n在组件被挂载到DOM后调用，且只会被调用一次。这时候已经可以获取到DOM结构，因此**依赖DOM节点的操作可以放到这个方法中**。这个方法**通常还会用于向服务器端请求数据**。在这个方法中调用this.setState会引起组件的重新渲染。\n\ncomponentDidMount是执行组件与服务器通信的最佳地方，原因主要有两个：\n\n1. 在componentDidMount中执行服务器通信可以保证获取到数据时，组件已经处于挂载状态，这时即使要直接操作DOM也是安全的，而componentWillMount无法保证这一点。如果要初始化第三方的dom库，也在这里进行初始化。\n2. 当组件在服务器端渲染时，componentWillMount会被调用两次，一次是在服务器端，另一次是在浏览器端，而componentDidMount能保证在任何情况下只会被调用一次，从而不会发送多余的数据请求.\n3. 注意它只能在浏览器端调用,在服务器端使用React的时候不会调用,装载是将组件渲染,并且构造DOM元素,然后塞入页面的过程,这个状态是不可能在服务器端完成的,服务器端不可能产生DOM树\n\n作用：\n\n1. 数据可以获取到，真实DOM也可以获取到\n2. 可以进行数据请求，进行数据修改，\n3. 是唯一一个可以同步修改state的方法,指的是数据发生改变之后，直接显示在视图上了\n4. 操作真实DOM【 第三方库的实例化 】\n\n#### 二、更新阶段\n\n**componentWillReceiveProps(nextProps)**\n\n这个方法只在props引起的组件更新过程中，才会被调用。不会在组件初始化props时调用这个方法，调用this.setState也不会触发\n\n只要父组件的render函数被调用,在render函数里面被渲染的子组件就会经历更新的过程,无论父组件传给子组件的props有没有改变,都会触发子组件的componentWillReceiveProps函数\n\n官方建议使用getDerivedStateFromProps函数代替componentWillReceiveProps。\n\n注意：在挂载过程中,React不会针对初始props调用此方法,更新阶段才会触发。可以理解为第一次渲染时,父组件的componentWillReceiveProps函数不会被执行,如果是第二次渲染时,已经存在于父组件中,则该componentWillReceiveProps才会执行\n\n**shouldComponentUpdate**\n\n调用shouldComponentUpdate使React知道，组件的输出是否受state和props的影响。默认每个状态的更改都会重新渲染，大多数情况下应该保持这个默认行为。\n\n默认只要状态变了，组件就会重新渲染，但是可以再这个生命周期中，通过返回false还是true来改变这个默认行为。\n\n它决定一个组件什么时候不需要被渲染,在组件更新过程中,Render函数之前调用执行,它同Render函数一样,要求有返回结果的函数\n\n返回一个boolean值,告诉React库这个组件在这次更新过程是否要继续,如果该函数返回true,那么继续更新,调用render函数,反之,若函数返回false,那么立刻停止更新过程,便不会执行render函数\n\n一般通过比较nextProps、nextState和组件当前的props、state决定这个方法的返回结果。这个方法可以用来减少组件不必要的渲染，从而优化组件的性能。\n\n如果发现没必要的渲染,那就干脆不用渲染了\n\n```js\nshouldComponentUpdate(nextProps,nextState){\n  //决定视图是否渲染，true渲染视图，false视图不渲染，必须要有这个返回值\n  if(nextProps.props.属性名 !== this.props.属性名 || nextState.state属性名 !== this.state.state属性名){\n    return true;\n  }else{\n    return false;\n  }\n}\n```\n\n**componentWillUpdate（nextProps,nextState）**\n\n可以作为组件更新发生前执行某些工作的地方，一般也很少用到。\n\n注：shouldComponentUpdate和componentWillUpdate中都不能调用setState，否则会引起循环调用问题，render永远无法被调用，组件也无法正常渲染。如果需要,则在componentWillReceiveProps函数中改变。或者调用getDerivedStateFromProps。\n\n> 这个钩子函数中切记不要使用 this.setState,会造成死循环\n\n**componentDidUpdate（prevProps,prevState）\n\n在更新发生后立即调用componentDidUpdate()。此方法不用于初始渲染。当组件更新时，将此作为一个机会来操作DOM。只要您将当前的props与以前的props进行比较（例如，如果props没有改变，则可能不需要网络请求），这也是做网络请求的好地方。\n\n> 注意：\n\n1. 无论是父组件props的修改还是state状态的更改都会触发该方法\n2. 在处理业务或发送网络请求时,一定要做好条件比较,否则容易造成死循环，因为无论是父组件props的修改还是state状态的更改都会触发该方法，所以一定要做好条件较\n\n#### 三、卸载阶段\n\n组件从DOM中被卸载的过程，这个过程中只有一个生命周期方法：\n\n**componentWillUnmount**\n\n在组件被卸载并销毁之前立即被调用。在此方法中执行任何必要的清理，例如使定时器无效，取消网络请求或清理在componentDidMount中创建的任何监听。\n\n主要是为了善后工作，比如关闭定时器，删除定义的对象\n\n#### 四、错误处理阶段\n\n新增的\n\n**componentDidCatch(error, info)**\n\n此生命周期在后代组件抛出错误后被调用。 它接收两个参数：\n\n- `error` —— 抛出的错误。\n- info-- 带有 `componentStack` key 的对象，其中包含有关组件引发错误的栈信息\n\n------\n\n新的生命周期增加了static getDerivedStateFromProps()以及getSnapshotBeforeUpdate()，废弃了原有的componentWillMount()、componentWillUpdate()以及componentWillReceiveProps()\n\n**原生命周期图**\n\n![origin-lifecycle](http://img-static.yidengxuetang.com/wxapp/issue-img/old-lifycycle.png)\n\n**新生命周期图**\n\n![new-lifecycle](http://img-static.yidengxuetang.com/wxapp/issue-img/new-lifycycle.png)\n\n**为什么要改变生命周期**\n\n从上面的生命周期的图中可以看出，被废弃的三个函数都是在render之前，因为fiber的出现，很可能因为高优先级任务的出现而打断现有任务导致它们会被执行多次\n\n另外的一个原因则是，React想约束使用者，好的框架能够让人不得已写出容易维护和扩展的代码，这一点又是从何谈起，我们可以从新增加以及即将废弃的生命周期分析入手\n\n1）componentWillMount\n\n首先这个函数的功能完全可以使用componentDidMount和constructor来代替，异步获取的数据的情况上面已经说明了，而如果抛去异步获取数据，其余的即是初始化而已，这些功能都可以在constructor中执行，除此之外，如果我们在willMount中订阅事件，但在服务端这并不会执行willUnMount事件，也就是说服务端会导致内存泄漏\n\n所以componentWillMount完全可以不使用，但使用者有时候难免因为各种各样的情况（如作者犯浑）在componentWillMount中做一些操作，那么React为了约束开发者，干脆就抛掉了这个API\n\n2）componentWillReceiveProps\n\n在老版本的 React 中，如果组件自身的某个 state 跟其 props 密切相关的话，一直都没有一种很优雅的处理方式去更新 state，而是需要在 componentWillReceiveProps 中判断前后两个 props 是否相同，如果不同再将新的 props 更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。类似的业务需求也有很多，如一个可以横向滑动的列表，当前高亮的 Tab 显然隶属于列表自身的状态，但很多情况下，业务需求会要求从外部跳转至列表时，根据传入的某个值，直接定位到某个 Tab。\n\n为了解决这些问题，React引入了第一个新的生命周期，getDerivedStateFromProps\n\n3）componentWillReceiveProps与getDerivedStateFromProps对比\n\n```js\n// 原有\ncomponentWillReceiveProps(nextProps){\n    if(nextProps.tab !== this.props.tab){\n        this.setState({\n            tab:nextProps.tab\n        })\n    }\n    this.tabChange();\n}\n\n// 新的\nstatic getDerivedStateFromProps(nextProps,prevState){\n    if(nextProps.tab !== prevState.tab){\n        return {\n            tab:nextProps.tab\n        }\n    }\n    return null;\n}\ncomponentDisUpdate(prevProps,prevState){\n    this.tabChange();\n}\n```\n\n看似乎没有什么改变，特别是当我们把this,tabChange也放在didUpdate中执行时（正确做法），完全没有不同，但这也是我们一开始想说的，React通过API来约束开发者写出更好的代码，而新的使用方法有以下的优点：\n\n1. getDSFP是静态方法，在这里不能使用this，也就是一个纯函数，开发者不能写出副作用的代码\n\n2. 开发者只能通过prevState而不是prevProps来做对比，保证了state和props之间的简单关系以及不需要处理第一次渲染时prevProps为空的情况\n\n3. 基于第一点，将状态变化（setState）和昂贵操作（tabChange）区分开，更加便于 render 和 commit 阶段操作或者说优化。\n\n4）componentWillUpdate\n\n与 componentWillReceiveProps 类似，许多开发者也会在 componentWillUpdate 中根据 props 的变化去触发一些回调。但不论是 componentWillReceiveProps 还是 componentWillUpdate，都有可能在一次更新中被调用多次，也就是说写在这里的回调函数也有可能会被调用多次，这显然是不可取的。与 componentDidMount 类似，componentDidUpdate 也不存在这样的问题，一次更新中 componentDidUpdate 只会被调用一次，所以将原先写在 componentWillUpdate 中的回调迁移至 componentDidUpdate 就可以解决这个问题。\n\n另外一种情况则是我们需要获取DOM元素状态，但是由于在fiber中，render可打断，可能在willMount中获取到的元素状态很可能与实际需要的不同，这个通常可以使用第二个新增的生命函数的解决，getSnapshotBeforeUpdate(prevProps, prevState) \n\n5）getSnapshotBeforeUpdate(prevProps, prevState) // 返回的值作为componentDidUpdate的第三个参数\n\n与willMount不同的是， getSnapshotBeforeUpdate会在最终确定的render执行之前执行，也就是能保证其获取到的元素状态与didUpdate中获取到的元素状态相同。官方参考代码\n\n```js\nclass ScrollingList extends React.Component {\n  constructor(props) {\n    super(props);\n    this.listRef = React.createRef();\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // 我们是否在 list 中添加新的 items ？\n    // 捕获滚动​​位置以便我们稍后调整滚动位置。\n    if (prevProps.list.length < this.props.list.length) {\n      const list = this.listRef.current;\n      return list.scrollHeight - list.scrollTop;\n    }\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，\n    // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。\n    //（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）\n    if (snapshot !== null) {\n      const list = this.listRef.current;\n      list.scrollTop = list.scrollHeight - snapshot;\n    }\n  }\n\n  render() {\n    return (\n      <div ref={this.listRef}>{/* ...contents... */}</div>\n    );\n  }\n}\n```\n",
        "answer": "",
        "biz_type": 1,
        "qid": 55,
        "subject": "",
        "title": "说一下 React 生命周期，以及都有哪些改变？为什么去掉了那几个旧的生命周期？"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 2,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhuantaiguanli.gif",
        "style_tpl": 0,
        "text": "缺少实战经验？一键解决！",
        "title": "【专题课：你不知道的硬核数据状态管理】",
        "url": "https://mp.weixin.qq.com/s/k6MblcpoJNaTpVVp5Z0eZA"
      },
      "corp_tag": ["滴滴", "挖财"],
      "is_favorite": false,
      "qid": 57,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 答案\n\nKeys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识\n\n在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性\n\n在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染\n\n此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系\n\n> 几点注意事项\n>\n> 1、key值一定要和具体的元素一一对应到。\n>\n> 2、尽量不要用数组的index去作为key。\n>\n> 3、永远不要试图在render的时候用随机数或者其他操作给元素加上不稳定的key，这样造成的性能开销比不加key的情况下更糟糕。\n",
        "answer": "",
        "biz_type": 1,
        "qid": 57,
        "subject": "",
        "title": "React key 是干嘛用的 为什么要加？key 主要是解决哪一类问题的"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 4,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhiyeguihua.gif",
        "style_tpl": 0,
        "text": "前端路上没人带，老走弯路？",
        "title": "【专题课：十年前端老兵亲述：我和前端这十年】",
        "url": "https://mp.weixin.qq.com/s/J4qABCwfd6HyafOLLSgbvQ"
      },
      "corp_tag": ["洋葱学院"],
      "is_favorite": false,
      "qid": 35,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 答案\n\n#### 简单封装一个数据持久化的组件\n\n```js\nlet storage={\n    set(key, value){//增加\n        localStorage.setItem(key, JSON.stringify(value));\n    },\n    get(key){//获取\n        return JSON.parse(localStorage.getItem(key));\n    },\n    remove(key){//删除\n        localStorage.removeItem(key);\n    }\n};\nexport default Storage;\n```\n\n#### 封装一个数据持久化的工具\n\n前端持久化，不用思考直接就能想到`localStorage`，没错，不管用什么库，说到持久化应该跟它脱不了干系。\n\n```js\nconst Storage = {\n// 存\n  set(k, v) {\n    localstorage.setItem(k, JSON.stringify(v))\n  },\n  // 取\n  get(k) {\n    return JSON.parse(localStorage.getItem(k))\n  },\n  // 删\n  del(k) {\n    localStorage.removeItem(k)\n  }\n}\n\nexport default Storage\n```\n\n管你什么框架，简单的持久化都好使吧，其实封装都多余。\n\n#### React周边的工具\n\n有个库叫做`redux-persist`，顾名思义，结合了`redux`来实现的数据持久化的那么一个工具。\n\n先猜测一下，可能是将`redux`中`store`里的数据缓存到浏览器的`localStorage`中。\n\n具体实现参考：\n\n```js\n// 前提第一步是得在项目中安装 redux-persist\n// npm i redux-persist\n\n// 1.既有的redux里逻辑不变，在此基础上加工一下store\n// src/redux/store/index.js\nimport { createStore } from 'redux'\nimport reducers from '../reducers/index.js'\nimport { persistStore, persistReducer } from 'redux-persist'\nimport storage from 'redux-persist/lib/storage'\nimport autoMergeLevel2 from 'redux-persist/lib/stateReconciler/autoMergeLevel2'\n\nconst persistConfig = {\n  key: 'root',\n  storage: storage,\n  stateReconciler: autoMergeLevel2,\n  whitelist: ['needStorage'] // 配置需要数据持久化的reducer\n}\n\nconst persistReducer = persistReducer(persistConfig, reducers)\n\nconst store = createStore(persistReducer)\n\nexport default store\nexport const persistor = persistStore(store)\n\n// 2. 在入口文件中， 将PersistGate作为页面内容的父标签\n// src/index.js\nimport React from 'react'\nimport ReactDom from 'react-dom'\nimport { Provider } from 'react-redux'\nimport store from './redux/store/index.js'\nimport { persistor } from './redux/store/index.js'\nimport { PersistGate } from 'redux-persist/lib/integration/react'\n\nReactDOM.render(\n  <Provider store={store}>\n  \t<PersistGate loading={null} persistor={persistor}>\n  \t// contents\n  \t</PersistGate>\n  </Provider>,\n\tdocument.getElementById('app')\n)\n```\n\n打开浏览器调试工具`Application`就会发现`localStorage`中有`persist`缓存数据，所以它的原理还是`localStorage`咯。\n\n\n#### 数据持久化注意事项\n\n1. 数据持久化本质是利用localstorage，同一个域名共享同一个, 且存储量不能超过5M，存储量太大会影响性能，建议不超过2.5M\n2. 如果要控制过期时间，可以在set数据时加个时间戳\n3. 注意JSON.stringify，有一些对象无法存储，例如function、正则等\n4. 若业务线众多，建议划分域名使用localstorage\n5. 跨页面传输数据，优先建议url传输数据",
        "answer": "",
        "biz_type": 1,
        "qid": 35,
        "subject": "",
        "title": "React 数据持久化有什么实践吗？"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 7,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/mianshi.gif",
        "style_tpl": 0,
        "text": "面试通不过，问啥都心慌",
        "title": "【专题课：面试官亲讲：中高级前端大厂面试秘籍】",
        "url": "https://mp.weixin.qq.com/s/4NBqKq2kdB7MCnv6BmPyRw"
      },
      "corp_tag": ["洋葱学院"],
      "is_favorite": false,
      "qid": 36,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 答案\n\n#### 1）共同点\n\n为了解决状态管理混乱，无法有效同步的问题\n\n统一维护管理应用状态；\n\n某一状态只有一个可信数据来源（通常命名为store，指状态容器）；\n\n操作更新状态方式统一，并且可控（通常以action方式提供更新状态的途径）；\n\n支持将store与React组件连接，如react-redux，mobx-react；\n\n\n#### 2）区别\n\n**Redux**\n\nRedux更多的是遵循Flux模式的一种实现，是一个JavaScript库，它关注点主要是以下几方面：\n\n- Action：一个JavaScript对象，描述动作相关信息，主要包含type属性和payload属性：\n    - type：action 类型；\n    - payload：负载数据；\n- Reducer：定义应用状态如何响应不同动作（action），如何更新状态；\n    - Store：管理action和reducer及其关系的对象，主要提供以下功能：\n    - 维护应用状态并支持访问状态（getState()）；\n    - 支持监听action的分发，更新状态（dispatch(action)）；\n    - 支持订阅store的变更（subscribe(listener)）；\n- 异步流：由于Redux所有对store状态的变更，都应该通过action触发，异步任务（通常都是业务或获取数据任务）也不例外，而为了不将业务或数据相关的任务混入React组件中，就需要使用其他框架配合管理异步任务流程，如redux-thunk，redux-saga等；\n\n**Mobx**\n\nMobx是一个透明函数响应式编程（Transparently Functional Reactive Programming，TFRP）的状态管理库，它使得状态管理简单可伸缩：\n\n- Action：定义改变状态的动作函数，包括如何变更状态；\n- Store：集中管理模块状态（State）和动作（action）\n- Derivation（衍生）：从应用状态中派生而出，且没有任何其他影响的数据\n\n**对比总结**\n\n1. redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中\n2. redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存数据，数据变化后自动处理响应的操作\n3. redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改\n4. mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用\n5. mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易\n",
        "answer": "",
        "biz_type": 1,
        "qid": 36,
        "subject": "",
        "title": "使用过 mobx 吗？mobx 和 redux 有什么区别？"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  },
  {
    "msg": "success",
    "result": {
      "ad": {
        "id": 4,
        "img_url": "http://img-static.yidengxuetang.com/wxapp/course_ad_gif/zhiyeguihua.gif",
        "style_tpl": 0,
        "text": "前端路上没人带，老走弯路？",
        "title": "【专题课：十年前端老兵亲述：我和前端这十年】",
        "url": "https://mp.weixin.qq.com/s/J4qABCwfd6HyafOLLSgbvQ"
      },
      "corp_tag": ["滴滴"],
      "is_favorite": false,
      "qid": 32,
      "qtype": "short_answer",
      "short_answer": {
        "analysis": "### 代码实现\n\n#### jsx代码\n\n```js\nimport React, { Component } from 'react';\nimport { is, fromJS } from 'immutable';\nimport ReactDOM from 'react-dom';\nimport ReactCSSTransitionGroup from 'react-addons-css-transition-group';\nimport './dialog.css';\nlet defaultState = {\n  alertStatus:false,\n  alertTip:\"提示\",\n  closeDialog:function(){},\n  childs:''\n}\nclass Dialog extends Component{\n  state = {\n    ...defaultState\n  };\n  // css动画组件设置为目标组件\n  FirstChild = props => {\n    const childrenArray = React.Children.toArray(props.children);\n    return childrenArray[0] || null;\n  }\n  //打开弹窗\n  open =(options)=>{\n    options = options || {};\n    options.alertStatus = true;\n    var props = options.props || {};\n    var childs = this.renderChildren(props,options.childrens) || '';\n    console.log(childs);\n    this.setState({\n      ...defaultState,\n      ...options,\n      childs\n    })\n  }\n  //关闭弹窗\n  close(){\n    this.state.closeDialog();\n    this.setState({\n      ...defaultState\n    })\n  }\n  renderChildren(props,childrens) {\n    //遍历所有子组件\n    var childs = [];\n    childrens = childrens || [];\n    var ps = {\n        ...props,  //给子组件绑定props\n        _close:this.close  //给子组件也绑定一个关闭弹窗的事件    \n       };\n    childrens.forEach((currentItem,index) => {\n        childs.push(React.createElement(\n            currentItem,\n            {\n                ...ps,\n                key:index\n            }\n        ));\n    })\n    return childs;\n  }\n  shouldComponentUpdate(nextProps, nextState){\n    return !is(fromJS(this.props), fromJS(nextProps)) || !is(fromJS(this.state), fromJS(nextState))\n  }\n   \n  render(){\n    return (\n      <ReactCSSTransitionGroup\n        component={this.FirstChild}\n        transitionName='hide'\n        transitionEnterTimeout={300}\n        transitionLeaveTimeout={300}>\n        <div className=\"dialog-con\" style={this.state.alertStatus? {display:'block'}:{display:'none'}}>\n            {this.state.childs}\n        </div>\n      </ReactCSSTransitionGroup>\n    );\n  }\n}\nlet div = document.createElement('div');\nlet props = {\n   \n};\ndocument.body.appendChild(div);\nlet Box = ReactD\n```\n\n```js\n//子类jsx\nimport React, { Component } from 'react';\nclass Child extends Component {\n    constructor(props){\n        super(props);\n        this.state = {date: new Date()};\n  }\n  showValue=()=>{\n    this.props.showValue && this.props.showValue()\n  }\n  render() {\n    return (\n      <div className=\"Child\">\n        <div className=\"content\">\n           Child\n           <button onClick={this.showValue}>调用父的方法</button>\n        </div>\n      </div>\n    );\n  }\n}\nexport default Child;\n```\n\n#### css代码\n\n```css\n.dialog-con{\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.3);\n}\n```",
        "answer": "",
        "biz_type": 1,
        "qid": 32,
        "subject": "",
        "title": "react 实现一个全局的 dialog"
      },
      "tech_tag": ["React"],
      "uid": 0
    },
    "status": 0
  }
]
