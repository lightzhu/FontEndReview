## 1. V8 如何执行一段 JS 代码

- 预解析：检查语法错误但不生成 AST
- 生成 AST：经过词法/语法分析，生成抽象语法树
- 生成字节码：基线编译器(Ignition)将 AST 转换成字节码
- 生成机器码：优化编译器(Turbofan)将字节码转换成优化过的机器码，此外在逐行执行字节码的过程中，如果一段代码经常被执行，那么 V8 会将这段代码直接转换成机码保存起来，下一次执行就不必经过字节码，优化了执行速度

## 2. 引用计数：

- 给一个变量赋值引用类型，则该对象的引用次数+1，如果这个变量变成了其他值，那么该对象的引用次数-1，垃圾回收器会回收引用次数为 0 的对象
- 标记清除：垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的等待回收的对象。

## 3. 根据浏览器渲染机制加快首屏速度

- 当 HTML 加载完成后会生成 dom 树，但是此时如果 CSS 的加载没有完成会阻塞 dom 渲染页面上会看不到元素，如果将外联样式放到 body 下面则不影响 dom 渲染，当 css 加载完成后会重新生成渲染树，然后根据渲染树进行重新布局。因此我们可以通过优化文件大小、减少 CSS 文件层级的方法来加快首屏速度
- 浏览器解析到`<script>`标签时，会阻塞文档解析，直到脚本执行完成，因此我们通常把`<script>`标签放在底部，或者加上 defer、async 来进行异步下载,defer 会在浏览器新开一个线程加载外部资源，和 defer 不同的是，async 会在脚本下载完成后立即执行，async 会在 load 事件之前执行，但并不能确保与 DOMContentLoaded 的执行先后顺序

## 4. 浏览器重绘回流，及 GPU 加速

- 当元素的尺寸或者位置发生了变化（offset/scroll/client/width/height/padding/margin/border），就需要重新计算渲染树，这就是回流
- DOM 样式发生了变化，但没有影响 DOM 的几何属性时，会触发重绘，而不会触发回流
- 使用 transform、opacity、filters 等属性时，会直接在 GPU 中完成处理，这些属性的变化不会引起回流重绘

## 5. 减少回流

- 使用 class 替代 style，减少 style 的使用，使用 resize、scroll 时进行防抖和节流处理，这两者会直接导致回流
- 使用 visibility 替换 display: none，因为前者只会引起重绘，后者会引发回流
- 批量修改元素时，可以先让元素脱离文档流，等修改完毕后，再放入文档流
- 避免触发同步布局事件，我们在获取 offsetWidth 这类属性的值时，可以使用变量将查询结果存起来，避免多次查询，每次对 offset/scroll/client 等属性进行查询时都会触发回流
- 对于复杂动画效果,使用绝对定位让其脱离文档流，复杂的动画效果会频繁地触发回流重绘，我们可以将动画元素设置绝对定位从而脱离文档流避免反复回流重绘。

## 6.缓存策略

- 设置 Expires：表示缓存会在这个时间后失效，这个过期日期是绝对日期，如果修改了本地日期，或者本地日期与服务器日期不一致，那么将导致缓存过期时间错误
- 设置 Cache-Control：Cache-Control 可以通过 max-age 字段来设置过期时间，例如「Cache-Control:max-age=3600」除此之外 Cache-Control 还能设置 private/no-cache 等多种字段
- Last-Modified：即最后修改时间，浏览器第一次请求资源时，服务器会在响应头上加上 Last-Modified ，当浏览器再次请求该资源时，浏览器会在请求头中带上 If-Modified-Since 字段，字段的值就是之前服务器返回的最后修改时间，服务器对比这两个时间，若相同则返回 304，否则返回新资源，并更新 Last-Modified
- ETag：表示文件唯一标识，只要文件内容改动，ETag 就会重新计算。缓存流程和 Last-Modified 一样：服务器发送 ETag 字段 -> 浏览器再次请求时发送 If-None-Match -> 如果 ETag 值不匹配，说明文件已经改变，返回新资源并更新 ETag，若匹配则返回 304

## 7.meta 有哪些属性

- viewport:包括 width/height、initial-scale 初始缩放比例、maximum-scale/minimum-scale、user-scalable，用户是否可以缩放 (yes/no)
- http-equive：expires，指定过期时间；progma，设置 no-cache 可以禁止缓存；refresh，定时刷新;set-cookie，可以设置 cookie
  ;X-UA-Compatible，使用浏览器版本;apple-mobile-web-app-status-bar-style，针对 WebApp 全屏模式，隐藏状态栏/设置状态栏颜色

## 8.清除浮动的方法

- 添加一个空元素，利用 css 提供的 clear:both 清除浮动
- 对父元素添加伪元素: `.parent::after{content: "";display: block;height: 0;clear:both}`
- 触发父元素 BFC:`overflow: hidden;or float: left/right;or position: absolute/fixed; or display: inline-block/table-cell/grid`

## 9.优化加载页面大量图片

- 图片懒加载。在页面的未可视区域添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。
- 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。
- 如果图片为 css 图片，可以使用 CSSsprite，SVGsprite 等技术。
- 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。
- 如果图片展示区域小于图片的真实大小，应在服务器端根据业务需要先进行图片压缩，图片压缩后大小与展示一致。

## 10.CommonJS，ES module 是什么

- 它们都是一种模块规范，例如 Node 使用的就是 CommonJS 规范。ES module 则是语言标准上的模块规范。
- CommonJS 模块使用 require() 和 module.exports={},exports.xxx= xxx，ES6 模块使用 import 和 export default ,export。
- CommonJS 模块输出的是一个值的浅拷贝，ES6 模块输出的是值的引用。
- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
- CommonJS 模块的 require() 是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段。
- ES6 模块之中，顶层的 this 指向 undefined；CommonJS 模块的顶层 this 指向当前模块，

## preload prefetch 和 defer

- preload 是 <link> 标签 rel 属性的属性值，同时需要配合 as 属性使用

```
<link rel="preload" href="https://unpkg.com/element-ui/lib/index.js" as="script">
<link rel="preload" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css" as="style">
```

- preload 不阻塞页面 onload 事件的情况下，去加载资源使用,preload 下载的资源只有在遇到同样的 script 标签时，才会执行对应的脚本;
- prefetch 属性指定的资源将在浏览器空闲时间下下载;
- defer 则是异步下载资源，在所有元素解析完成后，触发 DOMContentLoaded 事件前执行

## 什么情况下，用 translate()而不用绝对定位

- translate()是 transform 的一个值。改变 transform 或 opacity 不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。而改变绝对定位会触发重新布局，进而触发重绘和复合。transform 使浏览器为元素创建一个 GPU 图层，但改变绝对定位会使用到 CPU。 因此 translate()更高效，可以缩短平滑动画的绘制时间。

## 文本超出部分显示省略号

- 单行：overflow: hidden;text-overflow: ellipsis;white-space: nowrap;
- 多行：display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3; overflow: hidden;
