## 线程与进程

- 进程:
  - 程序的一次执行, 它占有一片独有的内存空间
  - 可以通过 windows 任务管理器查看进程
- 线程:
  - 是进程内的一个独立执行单元
  - 是程序执行的一个完整流程
  - 是 CPU 的最小的调度单元
- 关系
  - 一个进程至少有一个线程(主)
  - 程序是在某个进程中的某个线程执行的

## 浏览器内核模块组成

- 主线程
  - js 引擎模块 : 负责 js 程序的编译与运行
  - html,css 文档解析模块 : 负责页面文本的解析
  - DOM/CSS 模块 : 负责 dom/css 在内存中的相关处理
  - 布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)
- 分线程
  - 定时器模块 : 负责定时器的管理
  - DOM 事件模块 : 负责事件的管理
  - 网络请求模块 : 负责 Ajax 请求

## js 线程

- js 是单线程执行的(回调函数也是在主线程)
- H5 提出了实现多线程的方案: Web Workers
- 只能是主线程更新界面

## 定时器问题:

- 定时器并不真正完全定时
- 如果在主线程执行了一个长时间的操作, 可能导致延时才处理

## 事件处理机制(图)

- 代码分类
  - 初始化执行代码: 包含绑定 dom 事件监听, 设置定时器, 发送 ajax 请求的代码
  - 回调执行代码: 处理回调逻辑
- js 引擎执行代码的基本流程:
  - 初始化代码===>回调代码
- 模型的 2 个重要组成部分:
  - 事件管理模块
  - 回调队列
- 模型的运转流程
  - 执行初始化代码, 将事件回调函数交给对应模块管理
  - 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中
  - 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行

## 事件循环、宏任务、微任务

- 根据规范，事件循环是通过任务队列的机制来进行协调的。一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。 setTimeout/Promise 等 API 便是任务源，而进入任务队列的是他们指定的具体执行任务。
- (macro)task（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI 交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)
- microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前。所以它的响应速度相比 setTimeout（setTimeout 是 task）会更快，因为无需等渲染。也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）；主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)

## 循环机制：在事件循环中，每进行一次循环操作称为 tick

- 执行一个宏任务（栈中没有就从事件队列中获取）
- 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
- 当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染
- 渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取）

## H5 Web Workers

- 可以让 js 在分线程执行
- Worker
  ```
  var worker = new Worker('worker.js');
  worker.onMessage = function(event){event.data} : 用来接收另一个线程发送过来的数据的回调
  worker.postMessage(data1) : 向另一个线程发送数据
  ```
- 问题:
  - worker 内代码不能操作 DOM 更新 UI
  - 不是每个浏览器都支持这个新特性
  - 不能跨域加载 JS

## 浏览器和 Node 事件循环的区别

- 浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。宏任务队列可以有多个，微任务队列只有一个。
- Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js 采用 V8 作为 js 的解析引擎，而 I/O 处理方面使用了自己设计的 libuv，libuv 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 API，事件循环机制也是它里面的实现
- Node 事件循环：

  - timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。 同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行
  - poll ：回到 timer 阶段执行回调，执行 I/O 回调
  - check 阶段：setImmediate()的回调会被加入 check 队列中

- Node 端，microtask 在事件循环的各个阶段之间执行
- 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行
- 如果是 node11 版本一旦执行一个阶段里的一个宏任务，就立刻执行微任务队列，这就跟浏览器端运行一致
