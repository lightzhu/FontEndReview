## 观察者模式&发布订阅模式

- 在观察者模式中，观察者是知道 Subject 的，Subject 一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信
- 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反
- 观察者模式大多数时候是同步的，比如当事件触发，Subject 就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）
- 观察者 模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式

## 工厂模式

- 工厂模式中:我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象，用工厂方法代替 new 操作的一种模式。
- 单例模式:限制类实例化次数只能一次，一个类只有一个实例，并提供一个访问它的全局访问点,当我们调用这个方法时，如果类持有的引用不为空就返回该引用，否者就创建该类的实例，并且将实例引用赋值给该类保持的那个引用再返回
- 原型模式:指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象
- 适配器模式:将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
- 代理模式:为其他对象提供一种代理以控制对这个对象的访问
- 策略模式:策略模式指的是定义一系列的算法，并且把它们封装起来。因此对于一种业务场景，流程是一样的，但是具体规则会随着某些因素的 不同而不同
- 迭代器模式
- 观察者模式:定义了对象间一种一对多的依赖关系（一个目标者，即：被观察者，多个观察者），当目标对象 Subject 的状态发生改变时，所有依赖它的对象 Observer 都会得到通知
- 发布订阅模式

## 单例模式实现

`
function Singleton(name) {
this.name = name
this.eat=function(){
console.log('eat')
}
}
Singleton.getInstance = function(...args) {
if (!Singleton.instance) {
Singleton.instance = new Singleton('dog');
}
return Singleton.instance;
};
Singleton.instance = null;

`
