# 当浏览器地址栏中输入 url 发生的事情

## 解析 url

- 当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL 会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。

## 转换非 ASCII 的 Unicode 字符

- 浏览器检查输入是否含有不是 a-z， A-Z，0-9， - 或者 . 的字符,有的话，浏览器会对部分输入进行编码

## 检查 HSTS 列表

- 浏览器检查自带的“预加载 HSTS（HTTP 严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用 HTTPS 进行连接的网站
- 如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用 HTTP 协议发送
- 注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。

## DNS 查询

- 浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns）。
- 如果缓存中没有，就去调用 gethostbyname 库函数（操作系统不同函数也不同）进行查询。
- gethostbyname 函数在试图进行 DNS 解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 不同的操作系统有所不同
- 如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。
- DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。
- 如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP 查询
- 如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询

## ARP （地址解析协议）过程

- 首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC
- 如果缓存没有命中：查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。查询选择的网络接口的 MAC 地址,我们发送一个二层（ OSI 模型 中的数据链路层）ARP 请求
- 使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议
- 如果本地/ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回

## 使用套接字

- 当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 socket ，请求一个 TCP 流套接字，对应的参数是 AF_INET/AF_INET6 和 SOCK_STREAM 。

## TLS 握手

- 客户端发送一个 ClientHello 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。
- 服务器端向客户端返回一个 ServerHello 消息，消息中包含了服务器端的 TLS 版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥
- 客户端根据自己的信任 CA 列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥
- 服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥
- 客户端发送一个 Finished 消息给服务器端，使用对称密钥加密这次通讯的一个散列值
- 服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 Finished 消息，也使用协商好的对称密钥加密
- 从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容

## HTTP 协议

- HTTP/1.1 定义了“关闭连接”的选项 "close"，发送者使用这个选项指示这次连接在响应结束之后会断开,不支持持久连接的 HTTP/1.1 应用必须在每条消息中都包含 "close" 选项。在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的 200 OK
- 然后是一个换行，接下来有效载荷(payload)，也就是 www.google.com 的 HTML 内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供之后的请求重用。
- 如果浏览器发送的 HTTP 头部包含了足够多的信息（例如包含了 Etag 头部），以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:304 Not Modified;这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容
- 在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到 HTML 页面引入的所有资源（图片，CSS，favicon.ico 等等）全部都获取完毕，区别只是头部的 GET / HTTP/1.1 会变成 GET / URL HTTP/1.1 。

- 如果 HTML 引入了本域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 Host 头部会变成另外的域名。

## HTTP 服务器请求处理

- HTTP 请求方法(GET, POST, HEAD, PUT, DELETE, CONNECT, OPTIONS, 或者 TRACE)。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法
- 服务器验证其上已经配置了 域名 的虚拟主机
- 服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)
- 如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求
- 服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 "/" ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）
- 服务器会使用指定的处理程序分析处理这个文件，一般是通过流的形式输出结果给请求者

## 接下来就是浏览器的工作

- 当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：解析 —— HTML，CSS，JS
- html 渲染(html Parser) —— 构建 DOM 树;css 解析器生成 style rules;接着将 DOM Tree 与 Style Rules 合成为 Render Tree; 接着进⼊布局（Layout）阶段，也就是为每个节点分配⼀个应出现在屏幕上的确切坐标;随后调⽤ GPU 进⾏绘制（Paint），遍历 Render Tree 的节点，并将元素呈现出来

## HTML 解析

- 浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成 8kB 大小的分块传输;HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。
- 解析树是以 DOM 元素以及属性为节点的树。DOM 是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如 Javascript)的接口。树的根部是"Document"对象。整个 DOM 和 HTML 文档几乎是一对一的关系。

## 解析算法

- 由于 HTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们；解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容
- 所以 HTML 不能使用常见的自顶向下或自底向上方法来进行分析，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。

## 解析结束之后

- 浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。
- 此时浏览器把文档标记为可交互的（interactive），浏览器开始解析处于“推迟（deferred）”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成（complete）”，浏览器会触发“加载（load）”事件。
- 注意解析 HTML 网页时永远不会出现“无效语法（Invalid Syntax）”错误，浏览器会修复所有错误内容，然后继续解析。

## CSS 解析

- 根据 CSS 词法和句法 分析 CSS 文件和 <style> 标签包含的内容以及 style 属性的值
- 每个 CSS 文件都被解析成一个样式表对象（StyleSheet object），这个对象里包含了带有选择器的 CSS 规则，和对应 CSS 语法的对象
- CSS 解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器

## 页面渲染

- 通过遍历 DOM 节点树创建‘Frame 树’或者‘渲染树’，并计算每个节点的各个 CSS 样式值
- 通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算"Frame 树"中每个节点的首选(preferred)宽度
- 通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度
- 通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度
- 使用上面的计算结果构建每个节点的坐标
- 当存在元素使用 floated，位置有 absolutely 或 relatively 属性的时候，会有更多复杂的计算
- 创建 layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层
- 页面上的每个层都被分配了纹理
- 每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由 CPU 执行栅格化处理，或者直接通过 D2D/SkiaGL 在 GPU 上绘制
- 上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量
- 计算出各个层的最终位置，一组命令由 Direct3D/OpenGL 发出，GPU 命令缓冲区清空，命令传至 GPU 并异步渲染，帧被送到 Window Server。

## GPU 渲染

- 在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU
- 当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。

## 重绘和回流

- 当元素的尺寸或者位置发生了变化（offset/scroll/client/width/height/padding/margin/border），就需要重新计算渲染树，这就是回流
- DOM 样式发生了变化，但没有影响 DOM 的几何属性时，会触发重绘，而不会触发回流
- 使用 transform、opacity、filters 等属性时，会直接在 GPU 中完成处理，这些属性的变化不会引起回流重绘
